2023-08-25 13:28:19.247 UTC [1] LOG:  starting PostgreSQL 15.3 (Debian 15.3-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
2023-08-25 13:28:19.253 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2023-08-25 13:28:19.254 UTC [1] LOG:  listening on IPv6 address "::", port 5432
2023-08-25 13:28:19.287 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2023-08-25 13:28:19.409 UTC [30] LOG:  database system was interrupted; last known up at 2023-08-24 22:24:24 UTC
2023-08-25 13:28:29.431 UTC [30] LOG:  syncing data directory (pre-fsync), elapsed time: 10.01 s, current path: ./base/16906/3764
2023-08-25 13:28:46.057 UTC [30] LOG:  database system was not properly shut down; automatic recovery in progress
2023-08-25 13:28:46.188 UTC [30] LOG:  redo starts at 0/AD41C28
2023-08-25 13:28:46.189 UTC [30] LOG:  invalid record length at 0/AD41D10: wanted 24, got 0
2023-08-25 13:28:46.189 UTC [30] LOG:  redo done at 0/AD41CD8 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.01 s
2023-08-25 13:28:46.347 UTC [28] LOG:  checkpoint starting: end-of-recovery immediate wait
2023-08-25 13:28:46.443 UTC [28] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.021 s, sync=0.013 s, total=0.102 s; sync files=3, longest=0.005 s, average=0.005 s; distance=0 kB, estimate=0 kB
2023-08-25 13:28:46.527 UTC [1] LOG:  database system is ready to accept connections
2023-08-25 22:42:04.277 UTC [34] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-08-25 22:42:04.277 UTC [34] DETAIL:  parameters: $1 = '16537'
2023-08-25 22:42:04.340 UTC [34] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-08-25 22:42:04.340 UTC [34] DETAIL:  parameters: $1 = '16537'
2023-08-25 22:42:04.391 UTC [34] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-08-25 22:42:04.391 UTC [34] DETAIL:  parameters: $1 = 'jhon@gmail.com', $2 = '1', $3 = '0'
2023-08-25 22:42:04.445 UTC [34] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-08-25 22:42:04.445 UTC [34] DETAIL:  parameters: $1 = '16419'
2023-08-25 22:42:04.449 UTC [34] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-08-25 22:42:04.449 UTC [34] DETAIL:  parameters: $1 = '16419'
2023-08-25 22:42:04.492 UTC [34] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-08-25 22:42:04.492 UTC [34] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-08-25 22:42:23.483 UTC [34] LOG:  statement: SELECT 1
2023-08-25 22:42:23.485 UTC [34] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-08-25 22:42:23.485 UTC [34] DETAIL:  parameters: $1 = 'jhon@gmail.com', $2 = '1', $3 = '0'
2023-08-25 22:42:23.490 UTC [34] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-08-25 22:42:23.490 UTC [34] DETAIL:  parameters: $1 = '068063', $2 = '1', $3 = '0'
2023-08-25 22:42:23.499 UTC [34] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-08-25 22:42:23.499 UTC [34] DETAIL:  parameters: $1 = 'jhon@gmail.com', $2 = '1', $3 = '0'
2023-08-25 22:42:23.650 UTC [34] LOG:  statement: BEGIN
2023-08-25 22:42:23.733 UTC [34] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-08-25 22:42:23.733 UTC [34] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-08-25 22:42:23.769 UTC [34] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-08-25 22:42:23.769 UTC [34] DETAIL:  parameters: $1 = '15', $2 = '0'
2023-08-25 22:42:23.781 UTC [34] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-08-25 22:42:23.781 UTC [34] DETAIL:  parameters: $1 = 'd97beb60-086b-4278-a929-b4d59cf821a0', $2 = 'john italo lucas lima', $3 = 'jhon@gmail.com', $4 = '068063', $5 = 'M', $6 = '88999772728', $7 = '2023-08-25 22:42:23.647', $8 = '15', $9 = '6'
2023-08-25 22:42:23.815 UTC [34] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-08-25 22:42:23.815 UTC [34] DETAIL:  parameters: $1 = '822f6f1f-a367-4788-b7fe-112450e6a7f3', $2 = 'jhon@gmail.com', $3 = '$2b$10$TOmvkkyetxxeTpphOsSKQe6IkaXN2.2mTKfCAMS8vt0fVRPB/2Exi', $4 = 'aluno', $5 = 'd97beb60-086b-4278-a929-b4d59cf821a0'
2023-08-25 22:42:23.821 UTC [34] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-08-25 22:42:23.821 UTC [34] DETAIL:  parameters: $1 = 'd97beb60-086b-4278-a929-b4d59cf821a0', $2 = '1', $3 = '0'
2023-08-25 22:42:23.823 UTC [34] LOG:  statement: COMMIT
2023-08-25 22:42:47.054 UTC [34] LOG:  statement: SELECT 1
2023-08-25 22:42:47.057 UTC [34] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-08-25 22:42:47.057 UTC [34] DETAIL:  parameters: $1 = 'jhon@gmail.com', $2 = '1', $3 = '0'
2023-08-25 22:42:51.457 UTC [34] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-08-25 22:42:51.457 UTC [34] DETAIL:  parameters: $1 = 'jhon@gmail.com', $2 = '1', $3 = '0'
2023-08-25 22:42:58.963 UTC [37] LOG:  statement: SELECT CURRENT_SCHEMA() AS schema
2023-08-25 22:42:58.988 UTC [37] LOG:  statement: select version()
2023-08-25 22:42:58.992 UTC [37] LOG:  statement: 
	      SELECT      n.nspname as schema, t.typname as typename, t.oid::int4 as typeid
	      FROM        pg_type t
	      LEFT JOIN   pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	      WHERE       (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid))
	      AND     NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
	      AND     n.nspname NOT IN ('pg_catalog', 'information_schema');
	    
2023-08-25 22:42:59.043 UTC [37] LOG:  statement: select version()
2023-08-25 22:42:59.419 UTC [37] LOG:  execute <unnamed>: 
	    SELECT datname
	    FROM pg_database
	    WHERE datistemplate = $1
	    
	    ORDER BY datname
	  
2023-08-25 22:42:59.419 UTC [37] DETAIL:  parameters: $1 = 'f'
2023-08-25 22:42:59.800 UTC [38] LOG:  statement: select version()
2023-08-25 22:42:59.805 UTC [38] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-08-25 22:42:59.991 UTC [38] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-08-25 22:43:00.002 UTC [38] LOG:  statement: select version()
2023-08-25 22:43:00.009 UTC [38] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-08-25 22:43:00.096 UTC [38] LOG:  statement: select version()
2023-08-25 22:43:00.114 UTC [38] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-08-25 22:43:00.265 UTC [38] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-08-25 22:43:01.313 UTC [38] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:43:01.313 UTC [38] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-08-25 22:43:01.438 UTC [38] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:43:01.438 UTC [38] DETAIL:  parameters: $1 = 'Aluno', $2 = 'public'
2023-08-25 22:43:01.453 UTC [38] LOG:  statement: select version()
2023-08-25 22:43:01.456 UTC [38] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Aluno"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:43:01.620 UTC [38] LOG:  statement: select version()
2023-08-25 22:43:01.633 UTC [38] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:43:10.084 UTC [34] LOG:  statement: SELECT 1
2023-08-25 22:43:10.087 UTC [34] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-08-25 22:43:10.087 UTC [34] DETAIL:  parameters: $1 = 'jhon@gmail.com', $2 = '1', $3 = '0'
2023-08-25 22:44:34.866 UTC [28] LOG:  checkpoint starting: time
2023-08-25 22:44:35.750 UTC [28] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.776 s, sync=0.018 s, total=0.884 s; sync files=8, longest=0.005 s, average=0.003 s; distance=17 kB, estimate=17 kB
2023-08-25 22:46:12.281 UTC [42] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-08-25 22:46:12.281 UTC [42] DETAIL:  parameters: $1 = '16537'
2023-08-25 22:46:12.289 UTC [42] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-08-25 22:46:12.289 UTC [42] DETAIL:  parameters: $1 = '16537'
2023-08-25 22:46:12.301 UTC [42] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-08-25 22:46:12.301 UTC [42] DETAIL:  parameters: $1 = 'jhon@gmail.com', $2 = '1', $3 = '0'
2023-08-25 22:46:33.400 UTC [44] LOG:  statement: SELECT CURRENT_SCHEMA() AS schema
2023-08-25 22:46:33.406 UTC [44] LOG:  statement: select version()
2023-08-25 22:46:33.410 UTC [44] LOG:  statement: 
	      SELECT      n.nspname as schema, t.typname as typename, t.oid::int4 as typeid
	      FROM        pg_type t
	      LEFT JOIN   pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	      WHERE       (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid))
	      AND     NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
	      AND     n.nspname NOT IN ('pg_catalog', 'information_schema');
	    
2023-08-25 22:46:33.430 UTC [44] LOG:  statement: select version()
2023-08-25 22:46:33.709 UTC [44] LOG:  execute <unnamed>: 
	    SELECT datname
	    FROM pg_database
	    WHERE datistemplate = $1
	    
	    ORDER BY datname
	  
2023-08-25 22:46:33.709 UTC [44] DETAIL:  parameters: $1 = 'f'
2023-08-25 22:46:34.105 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:34.113 UTC [45] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-08-25 22:46:34.175 UTC [45] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-08-25 22:46:34.189 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:34.202 UTC [45] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-08-25 22:46:34.295 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:34.321 UTC [45] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-08-25 22:46:34.362 UTC [45] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-08-25 22:46:36.753 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:46:36.753 UTC [45] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-08-25 22:46:36.809 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:46:36.809 UTC [45] DETAIL:  parameters: $1 = 'Aluno', $2 = 'public'
2023-08-25 22:46:36.817 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:36.819 UTC [45] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Aluno"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:46:36.943 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:36.950 UTC [45] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:46:38.987 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:46:38.987 UTC [45] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoProfessorCursoDisciplina'
2023-08-25 22:46:39.031 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:46:39.031 UTC [45] DETAIL:  parameters: $1 = 'AlunoProfessorCursoDisciplina', $2 = 'public'
2023-08-25 22:46:39.040 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:39.045 UTC [45] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."AlunoProfessorCursoDisciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:46:39.096 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:39.105 UTC [45] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoProfessorCursoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:46:40.638 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:46:40.638 UTC [45] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-08-25 22:46:40.688 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:46:40.688 UTC [45] DETAIL:  parameters: $1 = 'Curso', $2 = 'public'
2023-08-25 22:46:40.719 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:40.723 UTC [45] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Curso"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:46:40.783 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:40.790 UTC [45] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:46:44.278 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:46:44.278 UTC [45] DETAIL:  parameters: $1 = 'public', $2 = 'CursoDisciplina'
2023-08-25 22:46:44.311 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:46:44.311 UTC [45] DETAIL:  parameters: $1 = 'CursoDisciplina', $2 = 'public'
2023-08-25 22:46:44.321 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:44.324 UTC [45] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."CursoDisciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:46:44.431 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:44.437 UTC [45] LOG:  statement: 
	    SELECT * 
	    FROM "public"."CursoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:46:45.835 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:46:45.835 UTC [45] DETAIL:  parameters: $1 = 'public', $2 = 'Departamento'
2023-08-25 22:46:45.883 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:46:45.883 UTC [45] DETAIL:  parameters: $1 = 'Departamento', $2 = 'public'
2023-08-25 22:46:45.905 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:45.950 UTC [45] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Departamento"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:46:46.034 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:46.041 UTC [45] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Departamento"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:46:47.758 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:46:47.758 UTC [45] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-08-25 22:46:47.801 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:46:47.801 UTC [45] DETAIL:  parameters: $1 = 'Disciplina', $2 = 'public'
2023-08-25 22:46:47.804 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:47.810 UTC [45] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Disciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:46:47.854 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:47.866 UTC [45] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:46:50.728 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:46:50.728 UTC [45] DETAIL:  parameters: $1 = 'public', $2 = 'Departamento'
2023-08-25 22:46:50.767 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:46:50.767 UTC [45] DETAIL:  parameters: $1 = 'Departamento', $2 = 'public'
2023-08-25 22:46:50.774 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:50.781 UTC [45] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Departamento"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:46:50.851 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:50.854 UTC [45] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Departamento"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:46:52.091 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:46:52.091 UTC [45] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-08-25 22:46:52.122 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:46:52.122 UTC [45] DETAIL:  parameters: $1 = 'Disciplina', $2 = 'public'
2023-08-25 22:46:52.133 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:52.138 UTC [45] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Disciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:46:52.193 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:52.203 UTC [45] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:46:54.063 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:46:54.063 UTC [45] DETAIL:  parameters: $1 = 'public', $2 = 'Professor'
2023-08-25 22:46:54.090 UTC [45] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:46:54.090 UTC [45] DETAIL:  parameters: $1 = 'Professor', $2 = 'public'
2023-08-25 22:46:54.112 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:54.117 UTC [45] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Professor"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:46:54.192 UTC [45] LOG:  statement: select version()
2023-08-25 22:46:54.201 UTC [45] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Professor"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:47:22.584 UTC [47] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:47:22.584 UTC [47] DETAIL:  parameters: $1 = 'public', $2 = 'ProfessorCursoDisciplina'
2023-08-25 22:47:22.650 UTC [47] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:47:22.650 UTC [47] DETAIL:  parameters: $1 = 'ProfessorCursoDisciplina', $2 = 'public'
2023-08-25 22:47:22.659 UTC [47] LOG:  statement: select version()
2023-08-25 22:47:22.664 UTC [47] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."ProfessorCursoDisciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:47:22.789 UTC [47] LOG:  statement: select version()
2023-08-25 22:47:22.812 UTC [47] LOG:  statement: 
	    SELECT * 
	    FROM "public"."ProfessorCursoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:47:24.138 UTC [47] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:47:24.138 UTC [47] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-08-25 22:47:24.205 UTC [47] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:47:24.205 UTC [47] DETAIL:  parameters: $1 = 'Turma', $2 = 'public'
2023-08-25 22:47:24.240 UTC [47] LOG:  statement: select version()
2023-08-25 22:47:24.243 UTC [47] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Turma"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:47:24.307 UTC [47] LOG:  statement: select version()
2023-08-25 22:47:24.312 UTC [47] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-08-25 22:47:26.244 UTC [47] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-08-25 22:47:26.244 UTC [47] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-08-25 22:47:26.280 UTC [47] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-08-25 22:47:26.280 UTC [47] DETAIL:  parameters: $1 = 'User', $2 = 'public'
2023-08-25 22:47:26.300 UTC [47] LOG:  statement: select version()
2023-08-25 22:47:26.303 UTC [47] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."User"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-08-25 22:47:26.370 UTC [47] LOG:  statement: select version()
2023-08-25 22:47:26.382 UTC [47] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
