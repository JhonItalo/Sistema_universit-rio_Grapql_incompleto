2023-07-05 13:24:06.198 UTC [1] LOG:  starting PostgreSQL 15.3 (Debian 15.3-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
2023-07-05 13:24:06.204 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2023-07-05 13:24:06.204 UTC [1] LOG:  listening on IPv6 address "::", port 5432
2023-07-05 13:24:06.329 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2023-07-05 13:24:06.600 UTC [31] LOG:  database system was shut down at 2023-07-04 23:11:37 UTC
2023-07-05 13:24:07.785 UTC [1] LOG:  database system is ready to accept connections
2023-07-05 13:29:06.601 UTC [29] LOG:  checkpoint starting: time
2023-07-05 13:29:06.756 UTC [29] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.041 s, sync=0.031 s, total=0.156 s; sync files=3, longest=0.013 s, average=0.011 s; distance=0 kB, estimate=0 kB
2023-07-05 13:34:43.224 UTC [60] LOG:  statement: SELECT CURRENT_SCHEMA() AS schema
2023-07-05 13:34:43.310 UTC [60] LOG:  statement: select version()
2023-07-05 13:34:43.314 UTC [60] LOG:  statement: 
	      SELECT      n.nspname as schema, t.typname as typename, t.oid::int4 as typeid
	      FROM        pg_type t
	      LEFT JOIN   pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	      WHERE       (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid))
	      AND     NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
	      AND     n.nspname NOT IN ('pg_catalog', 'information_schema');
	    
2023-07-05 13:34:43.536 UTC [60] LOG:  statement: select version()
2023-07-05 13:34:43.767 UTC [60] LOG:  execute <unnamed>: 
	    SELECT datname
	    FROM pg_database
	    WHERE datistemplate = $1
	    
	    ORDER BY datname
	  
2023-07-05 13:34:43.767 UTC [60] DETAIL:  parameters: $1 = 'f'
2023-07-05 13:34:44.005 UTC [61] LOG:  statement: select version()
2023-07-05 13:34:44.009 UTC [61] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 13:34:44.160 UTC [61] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 13:34:44.167 UTC [61] LOG:  statement: select version()
2023-07-05 13:34:44.170 UTC [61] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 13:34:44.230 UTC [61] LOG:  statement: select version()
2023-07-05 13:34:44.283 UTC [61] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 13:34:44.409 UTC [61] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 13:50:10.480 UTC [93] LOG:  execute s0: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE 1=1 OFFSET $1
2023-07-05 13:50:10.480 UTC [93] DETAIL:  parameters: $1 = '0'
2023-07-05 14:15:09.282 UTC [143] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:15:09.282 UTC [143] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:15:09.372 UTC [143] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:15:09.372 UTC [143] DETAIL:  parameters: $1 = 'Turma', $2 = 'public'
2023-07-05 14:15:09.387 UTC [143] LOG:  statement: select version()
2023-07-05 14:15:09.390 UTC [143] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Turma"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:15:09.475 UTC [143] LOG:  statement: select version()
2023-07-05 14:15:09.479 UTC [143] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:22:32.975 UTC [159] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:22:32.975 UTC [159] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:22:33.007 UTC [159] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:22:33.007 UTC [159] DETAIL:  parameters: $1 = 'Curso', $2 = 'public'
2023-07-05 14:22:33.014 UTC [159] LOG:  statement: select version()
2023-07-05 14:22:33.016 UTC [159] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Curso"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:22:33.076 UTC [159] LOG:  statement: select version()
2023-07-05 14:22:33.085 UTC [159] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:24:14.876 UTC [164] LOG:  execute s0: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE "public"."Curso"."nome" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:24:14.876 UTC [164] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:24:14.882 UTC [164] LOG:  statement: BEGIN
2023-07-05 14:24:14.886 UTC [164] LOG:  execute s1: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 14:24:14.886 UTC [164] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:24:14.891 UTC [164] LOG:  execute s2: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1)
2023-07-05 14:24:14.891 UTC [164] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação'
2023-07-05 14:24:14.895 UTC [164] LOG:  execute s3: DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:24:14.895 UTC [164] DETAIL:  parameters: $1 = '1', $2 = 'Bacharelado em ciencias da computação'
2023-07-05 14:24:14.917 UTC [164] ERROR:  update or delete on table "Curso" violates foreign key constraint "Turma_id_curso_fkey" on table "Turma"
2023-07-05 14:24:14.917 UTC [164] DETAIL:  Key (id)=(1) is still referenced from table "Turma".
2023-07-05 14:24:14.917 UTC [164] STATEMENT:  DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:24:14.919 UTC [164] LOG:  statement: ROLLBACK
2023-07-05 14:26:53.020 UTC [170] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:26:53.020 UTC [170] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 14:26:53.057 UTC [170] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:26:53.057 UTC [170] DETAIL:  parameters: $1 = 'Aluno', $2 = 'public'
2023-07-05 14:26:53.064 UTC [170] LOG:  statement: select version()
2023-07-05 14:26:53.067 UTC [170] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Aluno"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:26:53.162 UTC [170] LOG:  statement: select version()
2023-07-05 14:26:53.167 UTC [170] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:27:17.470 UTC [172] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:27:17.470 UTC [172] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:27:19.182 UTC [172] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:27:19.182 UTC [172] DETAIL:  parameters: $1 = 'public', $2 = 'CursoDisciplina'
2023-07-05 14:27:37.420 UTC [172] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:27:37.420 UTC [172] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 14:27:37.459 UTC [172] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:27:37.459 UTC [172] DETAIL:  parameters: $1 = 'Disciplina', $2 = 'public'
2023-07-05 14:27:37.461 UTC [172] LOG:  statement: select version()
2023-07-05 14:27:37.464 UTC [172] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Disciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:27:37.531 UTC [172] LOG:  statement: select version()
2023-07-05 14:27:37.538 UTC [172] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:27:59.008 UTC [174] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:27:59.008 UTC [174] DETAIL:  parameters: $1 = 'public', $2 = 'Professor'
2023-07-05 14:28:09.470 UTC [174] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:28:09.470 UTC [174] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:28:09.510 UTC [174] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:28:09.510 UTC [174] DETAIL:  parameters: $1 = 'Turma', $2 = 'public'
2023-07-05 14:28:09.517 UTC [174] LOG:  statement: select version()
2023-07-05 14:28:09.519 UTC [174] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Turma"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:28:09.598 UTC [174] LOG:  statement: select version()
2023-07-05 14:28:09.602 UTC [174] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:28:22.065 UTC [176] LOG:  execute s0: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE "public"."Curso"."nome" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:28:22.065 UTC [176] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:28:22.071 UTC [176] LOG:  execute s1: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE "public"."Turma"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:28:22.071 UTC [176] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:28:22.098 UTC [176] LOG:  execute s3: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 14:28:22.098 UTC [176] DETAIL:  parameters: $1 = '16419'
2023-07-05 14:28:22.125 UTC [176] LOG:  execute s4: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 14:28:22.125 UTC [176] DETAIL:  parameters: $1 = '16419'
2023-07-05 14:28:22.130 UTC [176] LOG:  execute s2: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:28:22.130 UTC [176] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:28:22.147 UTC [176] LOG:  execute s5: SELECT "public"."CursoDisciplina"."id", "public"."CursoDisciplina"."id_curso", "public"."CursoDisciplina"."id_disciplina" FROM "public"."CursoDisciplina" WHERE "public"."CursoDisciplina"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:28:22.147 UTC [176] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:28:22.152 UTC [176] LOG:  statement: BEGIN
2023-07-05 14:28:22.157 UTC [176] LOG:  execute s6: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 14:28:22.157 UTC [176] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:28:22.160 UTC [176] LOG:  execute s7: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1)
2023-07-05 14:28:22.160 UTC [176] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação'
2023-07-05 14:28:22.163 UTC [176] LOG:  execute s8: DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:28:22.163 UTC [176] DETAIL:  parameters: $1 = '1', $2 = 'Bacharelado em ciencias da computação'
2023-07-05 14:28:22.165 UTC [176] ERROR:  update or delete on table "Curso" violates foreign key constraint "Turma_id_curso_fkey" on table "Turma"
2023-07-05 14:28:22.165 UTC [176] DETAIL:  Key (id)=(1) is still referenced from table "Turma".
2023-07-05 14:28:22.165 UTC [176] STATEMENT:  DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:28:22.167 UTC [176] LOG:  statement: ROLLBACK
2023-07-05 14:29:07.801 UTC [29] LOG:  checkpoint starting: time
2023-07-05 14:29:08.079 UTC [29] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.222 s, sync=0.007 s, total=0.278 s; sync files=3, longest=0.004 s, average=0.003 s; distance=1 kB, estimate=1 kB
2023-07-05 14:30:44.294 UTC [182] LOG:  execute s0: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE "public"."Curso"."nome" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:30:44.294 UTC [182] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:30:44.299 UTC [182] LOG:  statement: BEGIN
2023-07-05 14:30:44.302 UTC [182] LOG:  execute s1: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 14:30:44.302 UTC [182] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:30:44.308 UTC [182] LOG:  execute s2: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE "public"."Turma"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:30:44.308 UTC [182] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:30:44.329 UTC [182] LOG:  execute s4: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 14:30:44.329 UTC [182] DETAIL:  parameters: $1 = '16419'
2023-07-05 14:30:44.337 UTC [182] LOG:  execute s5: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 14:30:44.337 UTC [182] DETAIL:  parameters: $1 = '16419'
2023-07-05 14:30:44.341 UTC [182] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:30:44.341 UTC [182] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:30:44.349 UTC [182] LOG:  execute s6: SELECT "public"."CursoDisciplina"."id", "public"."CursoDisciplina"."id_curso", "public"."CursoDisciplina"."id_disciplina" FROM "public"."CursoDisciplina" WHERE "public"."CursoDisciplina"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:30:44.349 UTC [182] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:30:44.352 UTC [182] LOG:  execute s7: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1)
2023-07-05 14:30:44.352 UTC [182] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação'
2023-07-05 14:30:44.355 UTC [182] LOG:  execute s8: DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:30:44.355 UTC [182] DETAIL:  parameters: $1 = '1', $2 = 'Bacharelado em ciencias da computação'
2023-07-05 14:30:44.357 UTC [182] ERROR:  update or delete on table "Curso" violates foreign key constraint "Turma_id_curso_fkey" on table "Turma"
2023-07-05 14:30:44.357 UTC [182] DETAIL:  Key (id)=(1) is still referenced from table "Turma".
2023-07-05 14:30:44.357 UTC [182] STATEMENT:  DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:30:44.358 UTC [182] LOG:  statement: ROLLBACK
2023-07-05 14:31:43.988 UTC [185] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:31:43.988 UTC [185] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:31:44.028 UTC [185] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:31:44.028 UTC [185] DETAIL:  parameters: $1 = 'Curso', $2 = 'public'
2023-07-05 14:31:44.037 UTC [185] LOG:  statement: select version()
2023-07-05 14:31:44.041 UTC [185] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Curso"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:31:44.135 UTC [185] LOG:  statement: select version()
2023-07-05 14:31:44.144 UTC [185] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:31:59.546 UTC [182] LOG:  statement: SELECT 1
2023-07-05 14:31:59.548 UTC [182] LOG:  execute s0: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE "public"."Curso"."nome" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:31:59.548 UTC [182] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:31:59.551 UTC [182] LOG:  statement: BEGIN
2023-07-05 14:31:59.553 UTC [182] LOG:  execute s1: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 14:31:59.553 UTC [182] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:31:59.555 UTC [182] LOG:  execute s2: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE "public"."Turma"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:31:59.555 UTC [182] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:31:59.557 UTC [182] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:31:59.557 UTC [182] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:31:59.559 UTC [182] LOG:  execute s6: SELECT "public"."CursoDisciplina"."id", "public"."CursoDisciplina"."id_curso", "public"."CursoDisciplina"."id_disciplina" FROM "public"."CursoDisciplina" WHERE "public"."CursoDisciplina"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:31:59.559 UTC [182] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:31:59.560 UTC [182] LOG:  execute s7: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1)
2023-07-05 14:31:59.560 UTC [182] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação'
2023-07-05 14:31:59.562 UTC [182] LOG:  execute s8: DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:31:59.562 UTC [182] DETAIL:  parameters: $1 = '1', $2 = 'Bacharelado em ciencias da computação'
2023-07-05 14:31:59.562 UTC [182] ERROR:  update or delete on table "Curso" violates foreign key constraint "Turma_id_curso_fkey" on table "Turma"
2023-07-05 14:31:59.562 UTC [182] DETAIL:  Key (id)=(1) is still referenced from table "Turma".
2023-07-05 14:31:59.562 UTC [182] STATEMENT:  DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:31:59.564 UTC [182] LOG:  statement: ROLLBACK
2023-07-05 14:34:07.125 UTC [29] LOG:  checkpoint starting: time
2023-07-05 14:34:07.410 UTC [29] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.223 s, sync=0.007 s, total=0.285 s; sync files=3, longest=0.005 s, average=0.003 s; distance=1 kB, estimate=1 kB
2023-07-05 14:39:08.298 UTC [200] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:39:08.298 UTC [200] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 14:39:08.336 UTC [200] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:39:08.336 UTC [200] DETAIL:  parameters: $1 = 'Aluno', $2 = 'public'
2023-07-05 14:39:08.350 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:08.355 UTC [200] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Aluno"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:39:08.555 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:08.561 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:11.400 UTC [200] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:39:11.400 UTC [200] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 14:39:11.425 UTC [200] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:39:11.425 UTC [200] DETAIL:  parameters: $1 = 'User', $2 = 'public'
2023-07-05 14:39:11.436 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:11.439 UTC [200] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."User"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:39:11.514 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:11.551 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:14.700 UTC [200] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:39:14.700 UTC [200] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 14:39:14.720 UTC [200] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:39:14.720 UTC [200] DETAIL:  parameters: $1 = 'Aluno', $2 = 'public'
2023-07-05 14:39:14.729 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:14.732 UTC [200] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Aluno"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:39:14.788 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:14.798 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:19.662 UTC [200] LOG:  statement: BEGIN
2023-07-05 14:39:19.665 UTC [200] LOG:  statement: 
2023-07-05 14:39:19.667 UTC [200] LOG:  statement: 
2023-07-05 14:39:19.670 UTC [200] LOG:  statement: 
2023-07-05 14:39:19.677 UTC [200] LOG:  statement: delete from "public"."Aluno" where "id" = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e'
2023-07-05 14:39:19.709 UTC [200] LOG:  statement: COMMIT
2023-07-05 14:39:19.731 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:19.737 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:22.802 UTC [200] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:39:22.802 UTC [200] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 14:39:22.821 UTC [200] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:39:22.821 UTC [200] DETAIL:  parameters: $1 = 'User', $2 = 'public'
2023-07-05 14:39:22.833 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:22.837 UTC [200] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."User"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:39:22.901 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:22.912 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:24.260 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:24.265 UTC [200] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 14:39:24.286 UTC [200] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 14:39:24.426 UTC [202] LOG:  statement: select version()
2023-07-05 14:39:24.429 UTC [202] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 14:39:24.452 UTC [202] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 14:39:24.456 UTC [202] LOG:  statement: select version()
2023-07-05 14:39:24.459 UTC [202] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 14:39:24.528 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:24.528 UTC [202] LOG:  statement: select version()
2023-07-05 14:39:24.553 UTC [202] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:24.554 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:24.561 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:24.575 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:24.586 UTC [200] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:39:24.586 UTC [200] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:39:24.616 UTC [200] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:39:24.616 UTC [200] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 14:39:24.625 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:24.645 UTC [202] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:39:24.645 UTC [202] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:39:24.691 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:24.698 UTC [202] LOG:  statement: select version()
2023-07-05 14:39:24.714 UTC [202] LOG:  statement: select version()
2023-07-05 14:39:24.716 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:24.916 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:24.917 UTC [203] LOG:  statement: select version()
2023-07-05 14:39:24.918 UTC [202] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:24.956 UTC [203] LOG:  statement: select version()
2023-07-05 14:39:24.956 UTC [202] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:24.956 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:24.960 UTC [203] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:24.964 UTC [202] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:24.978 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:24.983 UTC [202] LOG:  statement: select version()
2023-07-05 14:39:25.005 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.007 UTC [203] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.020 UTC [202] LOG:  statement: select version()
2023-07-05 14:39:25.035 UTC [205] LOG:  statement: select version()
2023-07-05 14:39:25.039 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:25.044 UTC [202] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.044 UTC [205] LOG:  statement: select version()
2023-07-05 14:39:25.045 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.049 UTC [202] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.062 UTC [202] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.064 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.099 UTC [203] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:39:25.099 UTC [203] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 14:39:25.119 UTC [205] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:39:25.119 UTC [205] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 14:39:25.150 UTC [200] LOG:  statement: select version()
2023-07-05 14:39:25.150 UTC [203] LOG:  statement: select version()
2023-07-05 14:39:25.150 UTC [202] LOG:  statement: select version()
2023-07-05 14:39:25.153 UTC [204] LOG:  statement: select version()
2023-07-05 14:39:25.159 UTC [205] LOG:  statement: select version()
2023-07-05 14:39:25.160 UTC [200] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.161 UTC [202] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.162 UTC [203] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.163 UTC [204] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.164 UTC [205] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.175 UTC [202] LOG:  statement: select version()
2023-07-05 14:39:25.179 UTC [203] LOG:  statement: select version()
2023-07-05 14:39:25.184 UTC [204] LOG:  statement: select version()
2023-07-05 14:39:25.185 UTC [202] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.187 UTC [203] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:39:25.189 UTC [204] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:00.228 UTC [207] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 14:40:00.228 UTC [207] DETAIL:  parameters: $1 = '16537'
2023-07-05 14:40:00.235 UTC [207] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 14:40:00.235 UTC [207] DETAIL:  parameters: $1 = '16537'
2023-07-05 14:40:00.241 UTC [207] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:40:00.241 UTC [207] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 14:40:00.248 UTC [207] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 14:40:00.248 UTC [207] DETAIL:  parameters: $1 = '16419'
2023-07-05 14:40:00.250 UTC [207] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 14:40:00.250 UTC [207] DETAIL:  parameters: $1 = '16419'
2023-07-05 14:40:00.255 UTC [207] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:40:00.255 UTC [207] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 14:40:00.259 UTC [207] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:40:00.259 UTC [207] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 14:40:00.373 UTC [207] LOG:  statement: BEGIN
2023-07-05 14:40:00.382 UTC [207] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 14:40:00.382 UTC [207] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:40:00.391 UTC [207] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 14:40:00.391 UTC [207] DETAIL:  parameters: $1 = '4', $2 = '0'
2023-07-05 14:40:00.398 UTC [207] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-05 14:40:00.398 UTC [207] DETAIL:  parameters: $1 = '9e15e1e0-2732-4564-9bd7-c622f82f904d', $2 = 'john italo lucas lima', $3 = 'jhon_italo2@hotmail.com', $4 = '06806374352', $5 = 'M', $6 = '88999772728', $7 = '2023-07-05 14:40:00.367', $8 = '4', $9 = '1'
2023-07-05 14:40:00.403 UTC [207] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-05 14:40:00.403 UTC [207] DETAIL:  parameters: $1 = '36908055-497b-469d-bace-2f59d121e735', $2 = 'jhon_italo2@hotmail.com', $3 = '$2b$10$99QCytxzduiD6ryvi40Wx.m3v4xJovyXlINAbVDqlyt.GLP50R6DO', $4 = 'aluno', $5 = '9e15e1e0-2732-4564-9bd7-c622f82f904d'
2023-07-05 14:40:00.409 UTC [207] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:40:00.409 UTC [207] DETAIL:  parameters: $1 = '9e15e1e0-2732-4564-9bd7-c622f82f904d', $2 = '1', $3 = '0'
2023-07-05 14:40:00.411 UTC [207] LOG:  statement: COMMIT
2023-07-05 14:40:02.816 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:02.822 UTC [209] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 14:40:02.864 UTC [209] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 14:40:02.873 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:02.876 UTC [209] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 14:40:02.960 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:02.975 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:02.985 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:02.993 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:02.994 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:02.996 UTC [209] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.002 UTC [208] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 14:40:03.003 UTC [209] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.073 UTC [209] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:40:03.073 UTC [209] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:40:03.077 UTC [208] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:40:03.077 UTC [208] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 14:40:03.176 UTC [209] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:40:03.176 UTC [209] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 14:40:03.196 UTC [208] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 14:40:03.291 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:03.411 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:03.427 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:03.433 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:03.435 UTC [211] LOG:  statement: select version()
2023-07-05 14:40:03.463 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:03.465 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:03.467 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:03.472 UTC [211] LOG:  statement: select version()
2023-07-05 14:40:03.473 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:03.476 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.481 UTC [209] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.485 UTC [211] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.485 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.488 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.495 UTC [209] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.520 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.525 UTC [209] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.530 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.534 UTC [211] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.535 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:03.540 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:03.557 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:03.559 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:03.565 UTC [211] LOG:  statement: select version()
2023-07-05 14:40:03.567 UTC [208] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:40:03.567 UTC [208] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:40:03.578 UTC [211] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.578 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:03.579 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.580 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.600 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.609 UTC [209] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.610 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:03.614 UTC [211] LOG:  statement: select version()
2023-07-05 14:40:03.626 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:03.629 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.640 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.640 UTC [211] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.693 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.705 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:03.715 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:03.716 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:03.739 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.011 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:04.011 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:04.012 UTC [211] LOG:  statement: select version()
2023-07-05 14:40:04.012 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:04.014 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:04.019 UTC [211] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.023 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.025 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.026 UTC [209] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.027 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.040 UTC [211] LOG:  statement: select version()
2023-07-05 14:40:04.050 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:04.065 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:04.079 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:04.089 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:04.095 UTC [211] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.099 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.101 UTC [209] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.102 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.106 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.759 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:04.759 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:04.759 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:04.760 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:04.765 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.770 UTC [209] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.773 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.774 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.789 UTC [209] LOG:  statement: select version()
2023-07-05 14:40:04.801 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:04.815 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:04.834 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:04.840 UTC [209] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.841 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.843 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:04.844 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:05.683 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:05.683 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:05.683 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:05.691 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:05.692 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:05.695 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:05.712 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:05.728 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:05.742 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:05.746 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:05.748 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:05.750 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:06.383 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:06.383 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:06.393 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:06.396 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:06.416 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:06.439 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:06.446 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:06.449 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:07.445 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:07.450 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:07.466 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:07.474 UTC [212] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:09.785 UTC [212] LOG:  statement: select version()
2023-07-05 14:40:09.789 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:09.790 UTC [212] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 14:40:09.791 UTC [210] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 14:40:09.815 UTC [212] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 14:40:09.818 UTC [210] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 14:40:09.824 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:09.826 UTC [210] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 14:40:09.878 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:09.907 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:09.934 UTC [210] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:40:09.934 UTC [210] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 14:40:09.976 UTC [208] LOG:  statement: select version()
2023-07-05 14:40:09.976 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:09.994 UTC [208] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:09.995 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:10.033 UTC [210] LOG:  statement: select version()
2023-07-05 14:40:10.035 UTC [210] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:40:58.098 UTC [215] LOG:  execute s0: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE "public"."Curso"."nome" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:40:58.098 UTC [215] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:40:58.105 UTC [215] LOG:  statement: BEGIN
2023-07-05 14:40:58.109 UTC [215] LOG:  execute s1: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 14:40:58.109 UTC [215] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:40:58.128 UTC [215] LOG:  execute s3: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 14:40:58.128 UTC [215] DETAIL:  parameters: $1 = '16419'
2023-07-05 14:40:58.138 UTC [215] LOG:  execute s4: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 14:40:58.138 UTC [215] DETAIL:  parameters: $1 = '16419'
2023-07-05 14:40:58.143 UTC [215] LOG:  execute s2: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:40:58.143 UTC [215] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:40:58.149 UTC [215] LOG:  execute s5: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE "public"."Turma"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:40:58.149 UTC [215] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:40:58.155 UTC [215] LOG:  execute s6: SELECT "public"."CursoDisciplina"."id", "public"."CursoDisciplina"."id_curso", "public"."CursoDisciplina"."id_disciplina" FROM "public"."CursoDisciplina" WHERE "public"."CursoDisciplina"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:40:58.155 UTC [215] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:40:58.158 UTC [215] LOG:  execute s7: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1)
2023-07-05 14:40:58.158 UTC [215] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação'
2023-07-05 14:40:58.161 UTC [215] LOG:  execute s8: DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:40:58.161 UTC [215] DETAIL:  parameters: $1 = '1', $2 = 'Bacharelado em ciencias da computação'
2023-07-05 14:40:58.163 UTC [215] ERROR:  update or delete on table "Curso" violates foreign key constraint "Turma_id_curso_fkey" on table "Turma"
2023-07-05 14:40:58.163 UTC [215] DETAIL:  Key (id)=(1) is still referenced from table "Turma".
2023-07-05 14:40:58.163 UTC [215] STATEMENT:  DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:40:58.165 UTC [215] LOG:  statement: ROLLBACK
2023-07-05 14:42:37.418 UTC [219] LOG:  statement: SET search_path = "public";
	
2023-07-05 14:42:37.421 UTC [219] LOG:  execute s0: SELECT version()
2023-07-05 14:42:37.428 UTC [219] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-05 14:42:37.428 UTC [219] DETAIL:  parameters: $1 = 'public'
2023-07-05 14:42:37.609 UTC [220] LOG:  statement: SET search_path = "public";
	
2023-07-05 14:42:37.612 UTC [220] LOG:  execute s0: SELECT version()
2023-07-05 14:42:37.620 UTC [220] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-05 14:42:37.620 UTC [220] DETAIL:  parameters: $1 = 'public'
2023-07-05 14:42:37.645 UTC [220] LOG:  execute s2: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-07-05 14:42:37.734 UTC [220] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_acee073b-cd53-4ee7-93de-54d32a5eef4a"
2023-07-05 14:42:43.654 UTC [222] LOG:  statement: SET search_path = "public";
	
2023-07-05 14:42:43.658 UTC [222] LOG:  execute s3: SELECT version()
2023-07-05 14:42:43.666 UTC [222] LOG:  execute s4: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-05 14:42:43.666 UTC [222] DETAIL:  parameters: $1 = 'public'
2023-07-05 14:42:43.668 UTC [222] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-05 14:42:43.729 UTC [222] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:43.784 UTC [222] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:43.879 UTC [222] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-05 14:42:43.928 UTC [222] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-05 14:42:43.945 UTC [222] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:43.994 UTC [222] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-05 14:42:44.029 UTC [222] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:44.077 UTC [222] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:44.133 UTC [222] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:44.194 UTC [222] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:44.265 UTC [222] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-05 14:42:44.271 UTC [222] LOG:  execute s5: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-05 14:42:44.271 UTC [222] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:44.283 UTC [222] LOG:  execute s6: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-05 14:42:44.283 UTC [222] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:44.300 UTC [222] LOG:  execute s7: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-05 14:42:44.300 UTC [222] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:44.307 UTC [222] LOG:  execute s8: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-05 14:42:44.307 UTC [222] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:44.315 UTC [222] LOG:  execute s9: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-05 14:42:44.315 UTC [222] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:44.343 UTC [222] LOG:  execute s10: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-05 14:42:44.343 UTC [222] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:44.358 UTC [222] LOG:  execute s11: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-05 14:42:44.358 UTC [222] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:44.375 UTC [222] LOG:  execute s12: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-05 14:42:44.375 UTC [222] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:44.388 UTC [222] LOG:  execute s13: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-05 14:42:44.388 UTC [222] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:44.396 UTC [222] LOG:  execute s14: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-05 14:42:44.400 UTC [222] LOG:  execute s15: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-05 14:42:44.400 UTC [222] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:44.403 UTC [220] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_acee073b-cd53-4ee7-93de-54d32a5eef4a"
2023-07-05 14:42:44.551 UTC [29] LOG:  checkpoint starting: immediate force wait
2023-07-05 14:42:44.683 UTC [29] LOG:  checkpoint complete: wrote 13 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.036 s, sync=0.018 s, total=0.132 s; sync files=13, longest=0.004 s, average=0.002 s; distance=4527 kB, estimate=4527 kB
2023-07-05 14:42:46.809 UTC [220] LOG:  execute s16: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-05 14:42:46.809 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:46.863 UTC [220] LOG:  execute s17: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-05 14:42:46.863 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:46.878 UTC [220] LOG:  execute s18: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-05 14:42:46.878 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:46.886 UTC [220] LOG:  execute s19: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-05 14:42:46.886 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:46.899 UTC [220] LOG:  execute s20: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-05 14:42:46.899 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:46.944 UTC [220] LOG:  execute s21: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-05 14:42:46.944 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:46.967 UTC [220] LOG:  execute s22: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-05 14:42:46.967 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:47.028 UTC [220] LOG:  execute s23: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-05 14:42:47.028 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:47.043 UTC [220] LOG:  execute s24: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-05 14:42:47.043 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:47.082 UTC [220] LOG:  execute s25: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-05 14:42:47.088 UTC [220] LOG:  execute s26: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-05 14:42:47.088 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:47.095 UTC [220] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_1d9d1e20-3b30-4100-be1f-87378173b6aa"
2023-07-05 14:42:50.475 UTC [223] LOG:  statement: SET search_path = "public";
	
2023-07-05 14:42:50.478 UTC [223] LOG:  execute s27: SELECT version()
2023-07-05 14:42:50.487 UTC [223] LOG:  execute s28: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-05 14:42:50.487 UTC [223] DETAIL:  parameters: $1 = 'public'
2023-07-05 14:42:50.489 UTC [223] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-05 14:42:50.563 UTC [223] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:50.624 UTC [223] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:50.710 UTC [223] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-05 14:42:50.773 UTC [223] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-05 14:42:50.792 UTC [223] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:50.850 UTC [223] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-05 14:42:50.888 UTC [223] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:50.936 UTC [223] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:50.993 UTC [223] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:51.052 UTC [223] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:51.126 UTC [223] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-05 14:42:51.133 UTC [223] LOG:  execute s29: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-05 14:42:51.133 UTC [223] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:51.146 UTC [223] LOG:  execute s30: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-05 14:42:51.146 UTC [223] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:51.158 UTC [223] LOG:  execute s31: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-05 14:42:51.158 UTC [223] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:51.164 UTC [223] LOG:  execute s32: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-05 14:42:51.164 UTC [223] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:51.171 UTC [223] LOG:  execute s33: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-05 14:42:51.171 UTC [223] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:51.202 UTC [223] LOG:  execute s34: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-05 14:42:51.202 UTC [223] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:51.218 UTC [223] LOG:  execute s35: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-05 14:42:51.218 UTC [223] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:51.237 UTC [223] LOG:  execute s36: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-05 14:42:51.237 UTC [223] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:51.252 UTC [223] LOG:  execute s37: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-05 14:42:51.252 UTC [223] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:51.261 UTC [223] LOG:  execute s38: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-05 14:42:51.267 UTC [223] LOG:  execute s39: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-05 14:42:51.267 UTC [223] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:51.269 UTC [220] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_1d9d1e20-3b30-4100-be1f-87378173b6aa"
2023-07-05 14:42:51.275 UTC [29] LOG:  checkpoint starting: immediate force wait
2023-07-05 14:42:51.482 UTC [29] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 1 recycled; write=0.040 s, sync=0.026 s, total=0.207 s; sync files=4, longest=0.022 s, average=0.007 s; distance=4520 kB, estimate=4526 kB
2023-07-05 14:42:53.231 UTC [220] LOG:  statement: SELECT pg_advisory_lock(72707369)
2023-07-05 14:42:53.243 UTC [220] LOG:  execute s40: 
	                SELECT tbl.relname AS table_name
	                FROM pg_class AS tbl
	                INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	                WHERE tbl.relkind = 'r' AND namespace.nspname = ANY ( $1 )
	            
2023-07-05 14:42:53.243 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:53.248 UTC [220] LOG:  execute s41: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-07-05 14:42:53.253 UTC [220] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_08e57cfd-a3c9-49f2-9752-152b8ad78eb9"
2023-07-05 14:42:56.679 UTC [224] LOG:  statement: SET search_path = "public";
	
2023-07-05 14:42:56.682 UTC [224] LOG:  execute s42: SELECT version()
2023-07-05 14:42:56.690 UTC [224] LOG:  execute s43: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-05 14:42:56.690 UTC [224] DETAIL:  parameters: $1 = 'public'
2023-07-05 14:42:56.692 UTC [224] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-05 14:42:56.746 UTC [224] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:56.792 UTC [224] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:56.859 UTC [224] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-05 14:42:56.904 UTC [224] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-05 14:42:56.920 UTC [224] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:56.964 UTC [224] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-05 14:42:56.994 UTC [224] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:57.036 UTC [224] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:57.083 UTC [224] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:57.136 UTC [224] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:42:57.203 UTC [224] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-05 14:42:57.209 UTC [224] LOG:  execute s44: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-05 14:42:57.209 UTC [224] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:57.220 UTC [224] LOG:  execute s45: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-05 14:42:57.220 UTC [224] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:57.229 UTC [224] LOG:  execute s46: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-05 14:42:57.229 UTC [224] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:57.234 UTC [224] LOG:  execute s47: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-05 14:42:57.234 UTC [224] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:57.241 UTC [224] LOG:  execute s48: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-05 14:42:57.241 UTC [224] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:57.262 UTC [224] LOG:  execute s49: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-05 14:42:57.262 UTC [224] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:57.275 UTC [224] LOG:  execute s50: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-05 14:42:57.275 UTC [224] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:57.291 UTC [224] LOG:  execute s51: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-05 14:42:57.291 UTC [224] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:57.303 UTC [224] LOG:  execute s52: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-05 14:42:57.303 UTC [224] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:57.310 UTC [224] LOG:  execute s53: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-05 14:42:57.314 UTC [224] LOG:  execute s54: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-05 14:42:57.314 UTC [224] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:42:57.316 UTC [220] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_08e57cfd-a3c9-49f2-9752-152b8ad78eb9"
2023-07-05 14:42:57.319 UTC [29] LOG:  checkpoint starting: immediate force wait
2023-07-05 14:42:57.453 UTC [29] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.028 s, sync=0.039 s, total=0.134 s; sync files=4, longest=0.034 s, average=0.010 s; distance=4521 kB, estimate=4526 kB
2023-07-05 14:44:04.207 UTC [220] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_d7061553-f3e8-4db1-b3fc-082de6eb5f40"
2023-07-05 14:44:07.739 UTC [227] LOG:  statement: SET search_path = "public";
	
2023-07-05 14:44:07.743 UTC [227] LOG:  execute s55: SELECT version()
2023-07-05 14:44:07.751 UTC [227] LOG:  execute s56: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-05 14:44:07.751 UTC [227] DETAIL:  parameters: $1 = 'public'
2023-07-05 14:44:07.753 UTC [227] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-05 14:44:07.815 UTC [227] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:44:07.869 UTC [227] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:44:07.949 UTC [227] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-05 14:44:07.999 UTC [227] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-05 14:44:08.016 UTC [227] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:44:08.065 UTC [227] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-05 14:44:08.096 UTC [227] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:44:08.140 UTC [227] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:44:08.193 UTC [227] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:44:08.251 UTC [227] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:44:08.318 UTC [227] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-05 14:44:08.325 UTC [227] LOG:  execute s57: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-05 14:44:08.325 UTC [227] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:08.338 UTC [227] LOG:  execute s58: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-05 14:44:08.338 UTC [227] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:08.348 UTC [227] LOG:  execute s59: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-05 14:44:08.348 UTC [227] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:08.353 UTC [227] LOG:  execute s60: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-05 14:44:08.353 UTC [227] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:08.360 UTC [227] LOG:  execute s61: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-05 14:44:08.360 UTC [227] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:08.382 UTC [227] LOG:  execute s62: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-05 14:44:08.382 UTC [227] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:08.395 UTC [227] LOG:  execute s63: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-05 14:44:08.395 UTC [227] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:08.414 UTC [227] LOG:  execute s64: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-05 14:44:08.414 UTC [227] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:08.427 UTC [227] LOG:  execute s65: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-05 14:44:08.427 UTC [227] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:08.434 UTC [227] LOG:  execute s66: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-05 14:44:08.438 UTC [227] LOG:  execute s67: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-05 14:44:08.438 UTC [227] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:08.440 UTC [220] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_d7061553-f3e8-4db1-b3fc-082de6eb5f40"
2023-07-05 14:44:08.583 UTC [29] LOG:  checkpoint starting: immediate force wait
2023-07-05 14:44:08.794 UTC [29] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.023 s, sync=0.007 s, total=0.211 s; sync files=4, longest=0.004 s, average=0.002 s; distance=4521 kB, estimate=4525 kB
2023-07-05 14:44:10.960 UTC [228] FATAL:  database "prisma_migrate_shadow_db_d7061553-f3e8-4db1-b3fc-082de6eb5f40" does not exist
2023-07-05 14:44:10.960 UTC [228] DETAIL:  It seems to have just been dropped or renamed.
2023-07-05 14:44:10.976 UTC [220] LOG:  statement: SELECT pg_advisory_lock(72707369)
2023-07-05 14:44:10.988 UTC [220] LOG:  execute s68: 
	                SELECT tbl.relname AS table_name
	                FROM pg_class AS tbl
	                INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	                WHERE tbl.relkind = 'r' AND namespace.nspname = ANY ( $1 )
	            
2023-07-05 14:44:10.988 UTC [220] DETAIL:  parameters: $1 = '{public}'
2023-07-05 14:44:10.994 UTC [220] LOG:  execute s69: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-07-05 14:44:10.998 UTC [220] LOG:  execute s70: INSERT INTO "_prisma_migrations" ("id","checksum","started_at","migration_name") VALUES ($1,$2,$3,$4)
2023-07-05 14:44:10.998 UTC [220] DETAIL:  parameters: $1 = '29d4d7ac-9ffc-4e09-85fa-ceb5db3622e4', $2 = '2e3bd14e46c8035e90cf8c120d854ead1c015246ce0ae94cfcc7c89b120e2c3c', $3 = '2023-07-05 14:44:10.995888+00', $4 = '20230705144410_add_delete_cascade_relation_curso'
2023-07-05 14:44:11.004 UTC [220] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-05 14:44:11.104 UTC [220] LOG:  execute s71: UPDATE "_prisma_migrations" SET "applied_steps_count" = ("applied_steps_count" + $1) WHERE "id" = $2
2023-07-05 14:44:11.104 UTC [220] DETAIL:  parameters: $1 = '1', $2 = '29d4d7ac-9ffc-4e09-85fa-ceb5db3622e4'
2023-07-05 14:44:11.110 UTC [220] LOG:  execute s72: UPDATE "_prisma_migrations" SET "finished_at" = $1 WHERE "id" = $2
2023-07-05 14:44:11.110 UTC [220] DETAIL:  parameters: $1 = '2023-07-05 14:44:11.108143+00', $2 = '29d4d7ac-9ffc-4e09-85fa-ceb5db3622e4'
2023-07-05 14:45:02.668 UTC [231] LOG:  execute s0: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE "public"."Curso"."nome" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:45:02.668 UTC [231] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:45:02.674 UTC [231] LOG:  statement: BEGIN
2023-07-05 14:45:02.677 UTC [231] LOG:  execute s1: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 14:45:02.677 UTC [231] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação', $2 = '1', $3 = '0'
2023-07-05 14:45:02.696 UTC [231] LOG:  execute s3: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 14:45:02.696 UTC [231] DETAIL:  parameters: $1 = '16419'
2023-07-05 14:45:02.705 UTC [231] LOG:  execute s4: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 14:45:02.705 UTC [231] DETAIL:  parameters: $1 = '16419'
2023-07-05 14:45:02.709 UTC [231] LOG:  execute s2: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:45:02.709 UTC [231] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:45:02.716 UTC [231] LOG:  execute s5: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE "public"."Turma"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:45:02.716 UTC [231] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:45:02.722 UTC [231] LOG:  execute s6: SELECT "public"."CursoDisciplina"."id", "public"."CursoDisciplina"."id_curso", "public"."CursoDisciplina"."id_disciplina" FROM "public"."CursoDisciplina" WHERE "public"."CursoDisciplina"."id_curso" IN ($1) OFFSET $2
2023-07-05 14:45:02.722 UTC [231] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:45:02.725 UTC [231] LOG:  execute s7: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1)
2023-07-05 14:45:02.725 UTC [231] DETAIL:  parameters: $1 = 'Bacharelado em ciencias da computação'
2023-07-05 14:45:02.728 UTC [231] LOG:  execute s8: DELETE FROM "public"."Curso" WHERE ("public"."Curso"."id" IN ($1) AND ("public"."Curso"."nome" = $2 AND 1=1))
2023-07-05 14:45:02.728 UTC [231] DETAIL:  parameters: $1 = '1', $2 = 'Bacharelado em ciencias da computação'
2023-07-05 14:45:02.739 UTC [231] LOG:  statement: COMMIT
2023-07-05 14:45:12.117 UTC [232] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:12.117 UTC [232] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:45:12.149 UTC [232] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:45:12.149 UTC [232] DETAIL:  parameters: $1 = 'Turma', $2 = 'public'
2023-07-05 14:45:12.156 UTC [232] LOG:  statement: select version()
2023-07-05 14:45:12.158 UTC [232] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Turma"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:45:12.215 UTC [232] LOG:  statement: select version()
2023-07-05 14:45:12.223 UTC [232] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:12.916 UTC [232] LOG:  statement: select version()
2023-07-05 14:45:12.920 UTC [232] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 14:45:12.940 UTC [232] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 14:45:13.087 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:13.090 UTC [233] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 14:45:13.120 UTC [233] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 14:45:13.125 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:13.128 UTC [233] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 14:45:13.183 UTC [232] LOG:  statement: select version()
2023-07-05 14:45:13.183 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:13.203 UTC [232] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:13.205 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:13.216 UTC [232] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:13.216 UTC [232] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:45:13.241 UTC [233] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:13.241 UTC [233] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 14:45:13.253 UTC [232] LOG:  statement: select version()
2023-07-05 14:45:13.288 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:13.303 UTC [232] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:13.313 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:13.325 UTC [232] LOG:  statement: select version()
2023-07-05 14:45:13.334 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:13.342 UTC [232] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:13.345 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:13.508 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:13.511 UTC [234] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:13.556 UTC [235] LOG:  statement: select version()
2023-07-05 14:45:13.559 UTC [235] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:15.545 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:15.545 UTC [235] LOG:  statement: select version()
2023-07-05 14:45:15.549 UTC [234] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 14:45:15.551 UTC [235] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 14:45:15.574 UTC [235] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 14:45:15.578 UTC [234] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 14:45:15.583 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:15.586 UTC [234] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 14:45:15.644 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:15.644 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:15.661 UTC [234] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:15.664 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:15.678 UTC [233] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:15.678 UTC [233] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:45:15.702 UTC [234] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:15.702 UTC [234] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 14:45:15.716 UTC [232] LOG:  statement: select version()
2023-07-05 14:45:15.717 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:15.745 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:15.752 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:15.755 UTC [232] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:15.768 UTC [234] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:15.772 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:15.792 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:15.793 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:15.805 UTC [234] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:15.974 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:15.977 UTC [236] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:17.632 UTC [236] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:17.632 UTC [236] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:45:17.660 UTC [236] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:45:17.660 UTC [236] DETAIL:  parameters: $1 = 'Curso', $2 = 'public'
2023-07-05 14:45:17.667 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:17.670 UTC [236] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Curso"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:45:17.712 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:17.719 UTC [236] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:20.114 UTC [236] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:20.114 UTC [236] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:45:20.155 UTC [236] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:45:20.155 UTC [236] DETAIL:  parameters: $1 = 'Turma', $2 = 'public'
2023-07-05 14:45:20.162 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:20.165 UTC [236] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Turma"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:45:20.229 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:20.234 UTC [236] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:21.291 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:21.291 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:21.301 UTC [236] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:21.303 UTC [234] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:21.311 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:21.323 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:21.329 UTC [236] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:21.333 UTC [234] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:22.120 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:22.120 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:22.125 UTC [236] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:22.128 UTC [234] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:22.136 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:22.145 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:22.150 UTC [236] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:22.153 UTC [234] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:23.650 UTC [234] LOG:  statement: select version()
2023-07-05 14:45:23.652 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:23.654 UTC [234] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 14:45:23.654 UTC [236] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 14:45:23.669 UTC [236] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 14:45:23.670 UTC [234] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 14:45:23.673 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:23.676 UTC [236] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 14:45:23.740 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:23.740 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:23.760 UTC [236] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:23.762 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:23.772 UTC [236] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:23.772 UTC [236] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:45:23.780 UTC [233] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:23.780 UTC [233] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:45:23.793 UTC [232] LOG:  statement: select version()
2023-07-05 14:45:23.794 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:23.822 UTC [235] LOG:  statement: select version()
2023-07-05 14:45:23.822 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:23.828 UTC [236] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:23.831 UTC [232] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:23.843 UTC [235] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:23.844 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:23.850 UTC [236] LOG:  statement: select version()
2023-07-05 14:45:23.855 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:23.858 UTC [236] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:23.859 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:38.742 UTC [231] LOG:  statement: SELECT 1
2023-07-05 14:45:38.744 UTC [231] LOG:  execute s0: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE "public"."Curso"."nome" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:45:38.744 UTC [231] DETAIL:  parameters: $1 = 'BCC', $2 = '1', $3 = '0'
2023-07-05 14:45:38.749 UTC [231] LOG:  statement: BEGIN
2023-07-05 14:45:38.782 UTC [231] LOG:  execute s9: SELECT "public"."Departamento"."id" FROM "public"."Departamento" WHERE ("public"."Departamento"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 14:45:38.782 UTC [231] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 14:45:38.787 UTC [231] LOG:  execute s10: INSERT INTO "public"."Curso" ("nome","id_departamento") VALUES ($1,$2) RETURNING "public"."Curso"."id"
2023-07-05 14:45:38.787 UTC [231] DETAIL:  parameters: $1 = 'BCC', $2 = '1'
2023-07-05 14:45:38.804 UTC [231] LOG:  execute s11: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE "public"."Curso"."id" = $1 LIMIT $2 OFFSET $3
2023-07-05 14:45:38.804 UTC [231] DETAIL:  parameters: $1 = '6', $2 = '1', $3 = '0'
2023-07-05 14:45:38.806 UTC [231] LOG:  statement: COMMIT
2023-07-05 14:45:43.562 UTC [233] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:43.562 UTC [233] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:45:43.589 UTC [233] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:45:43.589 UTC [233] DETAIL:  parameters: $1 = 'Turma', $2 = 'public'
2023-07-05 14:45:43.596 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:43.599 UTC [233] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Turma"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:45:43.662 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:43.666 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.139 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:54.143 UTC [233] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 14:45:54.164 UTC [233] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 14:45:54.318 UTC [237] LOG:  statement: select version()
2023-07-05 14:45:54.320 UTC [237] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 14:45:54.339 UTC [237] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 14:45:54.343 UTC [237] LOG:  statement: select version()
2023-07-05 14:45:54.346 UTC [237] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 14:45:54.400 UTC [237] LOG:  statement: select version()
2023-07-05 14:45:54.400 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:54.424 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.424 UTC [237] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.437 UTC [233] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:54.437 UTC [233] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:45:54.479 UTC [237] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:45:54.479 UTC [237] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:45:54.527 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:54.565 UTC [237] LOG:  statement: select version()
2023-07-05 14:45:54.574 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:54.624 UTC [237] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.628 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.631 UTC [237] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.636 UTC [237] LOG:  statement: select version()
2023-07-05 14:45:54.729 UTC [237] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.736 UTC [233] LOG:  statement: select version()
2023-07-05 14:45:54.752 UTC [233] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.811 UTC [238] LOG:  statement: select version()
2023-07-05 14:45:54.855 UTC [238] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.857 UTC [239] LOG:  statement: select version()
2023-07-05 14:45:54.861 UTC [239] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.871 UTC [238] LOG:  statement: select version()
2023-07-05 14:45:54.882 UTC [239] LOG:  statement: select version()
2023-07-05 14:45:54.884 UTC [238] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.888 UTC [239] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:45:54.934 UTC [240] LOG:  statement: select version()
2023-07-05 14:45:54.937 UTC [240] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:46:10.392 UTC [240] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:46:10.392 UTC [240] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:46:10.418 UTC [240] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:46:10.418 UTC [240] DETAIL:  parameters: $1 = 'Turma', $2 = 'public'
2023-07-05 14:46:10.424 UTC [240] LOG:  statement: select version()
2023-07-05 14:46:10.429 UTC [240] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Turma"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:46:10.472 UTC [240] LOG:  statement: select version()
2023-07-05 14:46:10.481 UTC [240] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:46:32.913 UTC [241] LOG:  statement: BEGIN
2023-07-05 14:46:32.966 UTC [241] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:46:32.966 UTC [241] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:46:32.979 UTC [241] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:46:32.979 UTC [241] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:46:32.988 UTC [241] LOG:  statement: insert into "public"."Turma" ("id_curso", "nome") values ('5', 'atomos');insert into "public"."Turma" ("id_curso", "nome") values ('6', 'programação')
2023-07-05 14:46:33.010 UTC [241] LOG:  statement: 
2023-07-05 14:46:33.012 UTC [241] LOG:  statement: 
2023-07-05 14:46:33.014 UTC [241] LOG:  statement: 
2023-07-05 14:46:33.017 UTC [241] LOG:  statement: COMMIT
2023-07-05 14:46:33.042 UTC [241] LOG:  statement: select version()
2023-07-05 14:46:33.054 UTC [241] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:46:37.176 UTC [241] LOG:  statement: select version()
2023-07-05 14:46:37.179 UTC [241] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 14:46:37.201 UTC [241] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 14:46:37.387 UTC [242] LOG:  statement: select version()
2023-07-05 14:46:37.391 UTC [242] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 14:46:37.431 UTC [242] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 14:46:37.439 UTC [242] LOG:  statement: select version()
2023-07-05 14:46:37.441 UTC [242] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 14:46:37.543 UTC [242] LOG:  statement: select version()
2023-07-05 14:46:37.567 UTC [242] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:46:37.655 UTC [242] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:46:37.655 UTC [242] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:46:37.690 UTC [242] LOG:  statement: select version()
2023-07-05 14:46:37.690 UTC [241] LOG:  statement: select version()
2023-07-05 14:46:37.697 UTC [241] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:46:37.698 UTC [242] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:46:37.774 UTC [242] LOG:  statement: select version()
2023-07-05 14:46:37.778 UTC [242] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:46:37.869 UTC [243] LOG:  statement: select version()
2023-07-05 14:46:37.872 UTC [243] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:46:37.925 UTC [243] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:46:37.925 UTC [243] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:46:37.969 UTC [242] LOG:  statement: select version()
2023-07-05 14:46:37.969 UTC [243] LOG:  statement: select version()
2023-07-05 14:46:37.979 UTC [243] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:46:37.981 UTC [242] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:46:37.989 UTC [243] LOG:  statement: select version()
2023-07-05 14:46:37.999 UTC [243] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:08.008 UTC [244] LOG:  statement: select version()
2023-07-05 14:47:08.011 UTC [244] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 14:47:08.037 UTC [244] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 14:47:08.059 UTC [245] LOG:  statement: select version()
2023-07-05 14:47:08.062 UTC [245] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 14:47:08.092 UTC [245] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 14:47:08.097 UTC [245] LOG:  statement: select version()
2023-07-05 14:47:08.100 UTC [245] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 14:47:08.173 UTC [245] LOG:  statement: select version()
2023-07-05 14:47:08.202 UTC [245] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:08.246 UTC [245] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:47:08.246 UTC [245] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:47:08.324 UTC [244] LOG:  statement: select version()
2023-07-05 14:47:08.324 UTC [245] LOG:  statement: select version()
2023-07-05 14:47:08.336 UTC [245] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:08.337 UTC [244] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:08.345 UTC [245] LOG:  statement: select version()
2023-07-05 14:47:08.349 UTC [245] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:08.390 UTC [246] LOG:  statement: select version()
2023-07-05 14:47:08.398 UTC [246] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:08.430 UTC [246] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:47:08.430 UTC [246] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 14:47:08.468 UTC [245] LOG:  statement: select version()
2023-07-05 14:47:08.468 UTC [246] LOG:  statement: select version()
2023-07-05 14:47:08.481 UTC [245] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:08.485 UTC [246] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:08.495 UTC [246] LOG:  statement: select version()
2023-07-05 14:47:08.503 UTC [246] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:21.310 UTC [246] LOG:  statement: BEGIN
2023-07-05 14:47:21.312 UTC [246] LOG:  statement: 
2023-07-05 14:47:21.344 UTC [246] LOG:  statement: update "public"."Turma" set "nome" = '2023.1' where "id" = 6;update "public"."Turma" set "nome" = '2023.1' where "id" = 7
2023-07-05 14:47:21.351 UTC [246] LOG:  statement: select * from "public"."Turma" where "id" = 6;select * from "public"."Turma" where "id" = 7
2023-07-05 14:47:21.353 UTC [246] LOG:  statement: 
2023-07-05 14:47:21.357 UTC [246] LOG:  statement: COMMIT
2023-07-05 14:47:29.862 UTC [246] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 14:47:29.862 UTC [246] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 14:47:29.901 UTC [246] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 14:47:29.901 UTC [246] DETAIL:  parameters: $1 = 'Curso', $2 = 'public'
2023-07-05 14:47:29.941 UTC [246] LOG:  statement: select version()
2023-07-05 14:47:29.944 UTC [246] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Curso"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 14:47:30.029 UTC [246] LOG:  statement: select version()
2023-07-05 14:47:30.040 UTC [246] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:30.083 UTC [247] LOG:  statement: select version()
2023-07-05 14:47:30.087 UTC [247] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:47:30.098 UTC [247] LOG:  statement: select version()
2023-07-05 14:47:30.102 UTC [247] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 14:48:19.353 UTC [1] LOG:  received fast shutdown request
2023-07-05 14:48:19.361 UTC [1] LOG:  aborting any active transactions
2023-07-05 14:48:19.365 UTC [1] LOG:  background worker "logical replication launcher" (PID 34) exited with exit code 1
2023-07-05 14:48:19.368 UTC [29] LOG:  shutting down
2023-07-05 14:48:19.376 UTC [29] LOG:  checkpoint starting: shutdown immediate
2023-07-05 14:48:19.531 UTC [29] LOG:  checkpoint complete: wrote 35 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.060 s, sync=0.037 s, total=0.163 s; sync files=30, longest=0.004 s, average=0.002 s; distance=99 kB, estimate=4083 kB
2023-07-05 14:48:19.607 UTC [1] LOG:  database system is shut down
