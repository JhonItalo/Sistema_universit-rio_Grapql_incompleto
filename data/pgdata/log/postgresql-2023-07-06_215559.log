2023-07-06 21:55:59.937 UTC [1] LOG:  starting PostgreSQL 15.3 (Debian 15.3-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
2023-07-06 21:55:59.939 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2023-07-06 21:55:59.939 UTC [1] LOG:  listening on IPv6 address "::", port 5432
2023-07-06 21:55:59.969 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2023-07-06 21:56:00.099 UTC [30] LOG:  database system was shut down at 2023-07-06 14:48:53 UTC
2023-07-06 21:56:00.365 UTC [1] LOG:  database system is ready to accept connections
2023-07-06 21:56:55.301 UTC [36] LOG:  statement: SELECT CURRENT_SCHEMA() AS schema
2023-07-06 21:56:55.345 UTC [36] LOG:  statement: select version()
2023-07-06 21:56:55.357 UTC [36] LOG:  statement: 
	      SELECT      n.nspname as schema, t.typname as typename, t.oid::int4 as typeid
	      FROM        pg_type t
	      LEFT JOIN   pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	      WHERE       (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid))
	      AND     NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
	      AND     n.nspname NOT IN ('pg_catalog', 'information_schema');
	    
2023-07-06 21:56:55.476 UTC [36] LOG:  statement: select version()
2023-07-06 21:56:55.848 UTC [36] LOG:  execute <unnamed>: 
	    SELECT datname
	    FROM pg_database
	    WHERE datistemplate = $1
	    
	    ORDER BY datname
	  
2023-07-06 21:56:55.848 UTC [36] DETAIL:  parameters: $1 = 'f'
2023-07-06 21:56:56.416 UTC [37] LOG:  statement: select version()
2023-07-06 21:56:56.421 UTC [37] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-06 21:56:56.523 UTC [37] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-06 21:56:56.539 UTC [37] LOG:  statement: select version()
2023-07-06 21:56:56.543 UTC [37] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-06 21:56:56.639 UTC [37] LOG:  statement: select version()
2023-07-06 21:56:56.670 UTC [37] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-06 21:56:56.781 UTC [37] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-06 21:56:58.348 UTC [36] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 21:56:58.348 UTC [36] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-06 21:56:58.553 UTC [36] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-06 21:56:58.553 UTC [36] DETAIL:  parameters: $1 = 'Aluno', $2 = 'public'
2023-07-06 21:56:58.592 UTC [36] LOG:  statement: select version()
2023-07-06 21:56:58.599 UTC [36] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Aluno"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-06 21:56:58.817 UTC [36] LOG:  statement: select version()
2023-07-06 21:56:58.838 UTC [36] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:01.273 UTC [36] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 21:57:01.273 UTC [36] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-06 21:57:01.319 UTC [36] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-06 21:57:01.319 UTC [36] DETAIL:  parameters: $1 = 'AlunoDisciplina', $2 = 'public'
2023-07-06 21:57:01.339 UTC [36] LOG:  statement: select version()
2023-07-06 21:57:01.360 UTC [36] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."AlunoDisciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-06 21:57:01.473 UTC [36] LOG:  statement: select version()
2023-07-06 21:57:01.481 UTC [36] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:04.191 UTC [36] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 21:57:04.191 UTC [36] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-06 21:57:04.237 UTC [36] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-06 21:57:04.237 UTC [36] DETAIL:  parameters: $1 = 'Curso', $2 = 'public'
2023-07-06 21:57:04.256 UTC [36] LOG:  statement: select version()
2023-07-06 21:57:04.260 UTC [36] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Curso"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-06 21:57:04.331 UTC [36] LOG:  statement: select version()
2023-07-06 21:57:04.341 UTC [36] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.230 UTC [36] LOG:  statement: select version()
2023-07-06 21:57:12.231 UTC [37] LOG:  statement: select version()
2023-07-06 21:57:12.234 UTC [36] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-06 21:57:12.237 UTC [37] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-06 21:57:12.247 UTC [36] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-06 21:57:12.250 UTC [37] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-06 21:57:12.256 UTC [37] LOG:  statement: select version()
2023-07-06 21:57:12.259 UTC [37] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-06 21:57:12.357 UTC [37] LOG:  statement: select version()
2023-07-06 21:57:12.394 UTC [37] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.439 UTC [37] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 21:57:12.439 UTC [37] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-06 21:57:12.579 UTC [36] LOG:  statement: select version()
2023-07-06 21:57:12.579 UTC [37] LOG:  statement: select version()
2023-07-06 21:57:12.685 UTC [37] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.688 UTC [36] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.689 UTC [40] LOG:  statement: select version()
2023-07-06 21:57:12.697 UTC [37] LOG:  statement: select version()
2023-07-06 21:57:12.703 UTC [40] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.707 UTC [37] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.765 UTC [40] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 21:57:12.765 UTC [40] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-06 21:57:12.810 UTC [37] LOG:  statement: select version()
2023-07-06 21:57:12.810 UTC [40] LOG:  statement: select version()
2023-07-06 21:57:12.820 UTC [39] LOG:  statement: select version()
2023-07-06 21:57:12.823 UTC [37] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.825 UTC [40] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.828 UTC [39] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.833 UTC [40] LOG:  statement: select version()
2023-07-06 21:57:12.848 UTC [40] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.882 UTC [39] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 21:57:12.882 UTC [39] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-06 21:57:12.929 UTC [40] LOG:  statement: select version()
2023-07-06 21:57:12.929 UTC [39] LOG:  statement: select version()
2023-07-06 21:57:12.942 UTC [40] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.944 UTC [39] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:12.949 UTC [39] LOG:  statement: select version()
2023-07-06 21:57:12.956 UTC [39] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 21:57:19.563 UTC [41] LOG:  execute s0: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE 1=1 OFFSET $1
2023-07-06 21:57:19.563 UTC [41] DETAIL:  parameters: $1 = '0'
2023-07-06 21:58:11.477 UTC [41] LOG:  statement: SELECT 1
2023-07-06 21:58:11.486 UTC [41] LOG:  execute s1: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE "public"."Curso"."nome" = $1 LIMIT $2 OFFSET $3
2023-07-06 21:58:11.486 UTC [41] DETAIL:  parameters: $1 = 'canna', $2 = '1', $3 = '0'
2023-07-06 21:58:11.494 UTC [41] LOG:  statement: BEGIN
2023-07-06 21:58:11.501 UTC [41] LOG:  execute s2: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."nome" = $1 AND 1=1)
2023-07-06 21:58:11.501 UTC [41] DETAIL:  parameters: $1 = 'canna'
2023-07-06 21:58:11.507 UTC [41] LOG:  execute s3: UPDATE "public"."Curso" SET "nome" = $1 WHERE ("public"."Curso"."id" IN ($2) AND ("public"."Curso"."nome" = $3 AND 1=1))
2023-07-06 21:58:11.507 UTC [41] DETAIL:  parameters: $1 = 'analise de algoritimos', $2 = '5', $3 = 'canna'
2023-07-06 21:58:11.521 UTC [41] LOG:  execute s4: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE "public"."Curso"."id" = $1 LIMIT $2 OFFSET $3
2023-07-06 21:58:11.521 UTC [41] DETAIL:  parameters: $1 = '5', $2 = '1', $3 = '0'
2023-07-06 21:58:11.523 UTC [41] LOG:  statement: COMMIT
2023-07-06 21:58:18.245 UTC [41] LOG:  execute s0: SELECT "public"."Curso"."id", "public"."Curso"."nome", "public"."Curso"."id_departamento" FROM "public"."Curso" WHERE 1=1 OFFSET $1
2023-07-06 21:58:18.245 UTC [41] DETAIL:  parameters: $1 = '0'
2023-07-06 21:58:52.398 UTC [41] LOG:  statement: SELECT 1
2023-07-06 21:58:52.406 UTC [41] LOG:  execute s5: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-06 21:58:52.406 UTC [41] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-06 21:58:52.415 UTC [41] LOG:  execute s6: SELECT "public"."Disciplina"."id", "public"."Disciplina"."nome" FROM "public"."Disciplina" WHERE "public"."Disciplina"."id" IN ($1,$2) OFFSET $3
2023-07-06 21:58:52.415 UTC [41] DETAIL:  parameters: $1 = '1', $2 = '2', $3 = '0'
2023-07-06 22:00:44.098 UTC [49] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_aluno", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-06 22:00:44.098 UTC [49] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-06 22:00:44.106 UTC [49] LOG:  execute s1: SELECT "public"."Disciplina"."id", "public"."Disciplina"."nome" FROM "public"."Disciplina" WHERE "public"."Disciplina"."id" IN ($1,$2) OFFSET $3
2023-07-06 22:00:44.106 UTC [49] DETAIL:  parameters: $1 = '1', $2 = '2', $3 = '0'
2023-07-06 22:01:00.184 UTC [28] LOG:  checkpoint starting: time
2023-07-06 22:01:00.680 UTC [28] LOG:  checkpoint complete: wrote 5 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.336 s, sync=0.022 s, total=0.497 s; sync files=6, longest=0.006 s, average=0.004 s; distance=1 kB, estimate=1 kB
2023-07-06 22:01:05.415 UTC [51] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_aluno", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-06 22:01:05.415 UTC [51] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-06 22:01:05.422 UTC [51] LOG:  execute s1: SELECT "public"."Disciplina"."id", "public"."Disciplina"."nome" FROM "public"."Disciplina" WHERE "public"."Disciplina"."id" IN ($1,$2) OFFSET $3
2023-07-06 22:01:05.422 UTC [51] DETAIL:  parameters: $1 = '1', $2 = '2', $3 = '0'
2023-07-06 22:01:46.648 UTC [53] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-06 22:01:46.648 UTC [53] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-06 22:01:46.655 UTC [53] LOG:  execute s1: SELECT "public"."Disciplina"."id", "public"."Disciplina"."nome" FROM "public"."Disciplina" WHERE "public"."Disciplina"."id" IN ($1,$2) OFFSET $3
2023-07-06 22:01:46.655 UTC [53] DETAIL:  parameters: $1 = '1', $2 = '2', $3 = '0'
2023-07-06 22:02:37.448 UTC [56] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-06 22:02:37.448 UTC [56] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-06 22:02:37.455 UTC [56] LOG:  execute s1: SELECT "public"."Disciplina"."id", "public"."Disciplina"."nome" FROM "public"."Disciplina" WHERE "public"."Disciplina"."id" IN ($1,$2) OFFSET $3
2023-07-06 22:02:37.455 UTC [56] DETAIL:  parameters: $1 = '1', $2 = '2', $3 = '0'
2023-07-06 22:03:25.749 UTC [56] LOG:  statement: SELECT 1
2023-07-06 22:03:25.752 UTC [56] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-06 22:03:25.752 UTC [56] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-06 22:03:25.753 UTC [56] LOG:  execute s1: SELECT "public"."Disciplina"."id", "public"."Disciplina"."nome" FROM "public"."Disciplina" WHERE "public"."Disciplina"."id" IN ($1,$2) OFFSET $3
2023-07-06 22:03:25.753 UTC [56] DETAIL:  parameters: $1 = '1', $2 = '2', $3 = '0'
2023-07-06 22:12:10.593 UTC [76] LOG:  statement: select version()
2023-07-06 22:12:10.596 UTC [76] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:12:10.633 UTC [76] LOG:  statement: select version()
2023-07-06 22:12:10.646 UTC [76] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:12:11.166 UTC [76] LOG:  statement: select version()
2023-07-06 22:12:11.172 UTC [76] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:12:11.198 UTC [76] LOG:  statement: select version()
2023-07-06 22:12:11.205 UTC [76] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:12:14.724 UTC [76] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 22:12:14.724 UTC [76] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-06 22:12:14.760 UTC [76] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-06 22:12:14.760 UTC [76] DETAIL:  parameters: $1 = 'Turma', $2 = 'public'
2023-07-06 22:12:14.767 UTC [76] LOG:  statement: select version()
2023-07-06 22:12:14.770 UTC [76] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Turma"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-06 22:12:14.826 UTC [76] LOG:  statement: select version()
2023-07-06 22:12:14.840 UTC [76] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:39:20.403 UTC [131] LOG:  execute s0: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2) LIMIT $3 OFFSET $4
2023-07-06 22:39:20.403 UTC [131] DETAIL:  parameters: $1 = '2025.1', $2 = '6', $3 = '1', $4 = '0'
2023-07-06 22:39:20.407 UTC [131] LOG:  statement: BEGIN
2023-07-06 22:39:20.416 UTC [131] LOG:  execute s1: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-06 22:39:20.416 UTC [131] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-06 22:39:20.420 UTC [131] LOG:  execute s2: INSERT INTO "public"."Turma" ("nome","id_curso") VALUES ($1,$2) RETURNING "public"."Turma"."id"
2023-07-06 22:39:20.420 UTC [131] DETAIL:  parameters: $1 = '2025.1', $2 = '6'
2023-07-06 22:39:20.439 UTC [131] LOG:  execute s3: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE "public"."Turma"."id" = $1 LIMIT $2 OFFSET $3
2023-07-06 22:39:20.439 UTC [131] DETAIL:  parameters: $1 = '8', $2 = '1', $3 = '0'
2023-07-06 22:39:20.440 UTC [131] LOG:  statement: COMMIT
2023-07-06 22:39:31.186 UTC [132] LOG:  statement: select version()
2023-07-06 22:39:31.190 UTC [132] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-06 22:39:31.221 UTC [132] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-06 22:39:31.244 UTC [133] LOG:  statement: select version()
2023-07-06 22:39:31.247 UTC [133] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-06 22:39:31.279 UTC [133] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-06 22:39:31.286 UTC [133] LOG:  statement: select version()
2023-07-06 22:39:31.288 UTC [133] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-06 22:39:31.357 UTC [133] LOG:  statement: select version()
2023-07-06 22:39:31.385 UTC [133] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:39:31.414 UTC [133] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 22:39:31.414 UTC [133] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-06 22:39:31.451 UTC [133] LOG:  statement: select version()
2023-07-06 22:39:31.451 UTC [132] LOG:  statement: select version()
2023-07-06 22:39:31.457 UTC [132] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:39:31.460 UTC [133] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:39:31.466 UTC [133] LOG:  statement: select version()
2023-07-06 22:39:31.473 UTC [133] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:39:38.344 UTC [131] LOG:  statement: SELECT 1
2023-07-06 22:39:38.347 UTC [131] LOG:  execute s0: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2) LIMIT $3 OFFSET $4
2023-07-06 22:39:38.347 UTC [131] DETAIL:  parameters: $1 = '2025.1', $2 = '6', $3 = '1', $4 = '0'
2023-07-06 22:39:43.251 UTC [133] LOG:  statement: select version()
2023-07-06 22:39:43.253 UTC [132] LOG:  statement: select version()
2023-07-06 22:39:43.255 UTC [133] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-06 22:39:43.256 UTC [132] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-06 22:39:43.270 UTC [133] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-06 22:39:43.276 UTC [132] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-06 22:39:43.288 UTC [132] LOG:  statement: select version()
2023-07-06 22:39:43.292 UTC [132] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-06 22:39:43.372 UTC [132] LOG:  statement: select version()
2023-07-06 22:39:43.417 UTC [132] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:39:43.484 UTC [132] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 22:39:43.484 UTC [132] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-06 22:39:43.543 UTC [132] LOG:  statement: select version()
2023-07-06 22:39:43.545 UTC [133] LOG:  statement: select version()
2023-07-06 22:39:43.552 UTC [132] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:39:43.554 UTC [133] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:39:43.559 UTC [132] LOG:  statement: select version()
2023-07-06 22:39:43.564 UTC [132] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:40:59.623 UTC [137] LOG:  execute s0: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2) LIMIT $3 OFFSET $4
2023-07-06 22:40:59.623 UTC [137] DETAIL:  parameters: $1 = '2025.1', $2 = '6', $3 = '1', $4 = '0'
2023-07-06 22:41:01.105 UTC [28] LOG:  checkpoint starting: time
2023-07-06 22:41:01.741 UTC [28] LOG:  checkpoint complete: wrote 6 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.537 s, sync=0.043 s, total=0.637 s; sync files=6, longest=0.018 s, average=0.008 s; distance=1 kB, estimate=1 kB
2023-07-06 22:41:36.729 UTC [140] LOG:  execute s0: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2) LIMIT $3 OFFSET $4
2023-07-06 22:41:36.729 UTC [140] DETAIL:  parameters: $1 = '2025.1', $2 = '6', $3 = '1', $4 = '0'
2023-07-06 22:41:58.316 UTC [141] LOG:  execute s0: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2) LIMIT $3 OFFSET $4
2023-07-06 22:41:58.316 UTC [141] DETAIL:  parameters: $1 = '2025.1', $2 = '6', $3 = '1', $4 = '0'
2023-07-06 22:42:18.624 UTC [143] LOG:  execute s0: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2) LIMIT $3 OFFSET $4
2023-07-06 22:42:18.624 UTC [143] DETAIL:  parameters: $1 = '2025.1', $2 = '6', $3 = '1', $4 = '0'
2023-07-06 22:42:55.779 UTC [143] LOG:  statement: SELECT 1
2023-07-06 22:42:55.783 UTC [143] LOG:  execute s0: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2) LIMIT $3 OFFSET $4
2023-07-06 22:42:55.783 UTC [143] DETAIL:  parameters: $1 = '2025.1', $2 = '6', $3 = '1', $4 = '0'
2023-07-06 22:57:17.373 UTC [174] LOG:  statement: select version()
2023-07-06 22:57:17.377 UTC [174] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-06 22:57:17.409 UTC [174] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-06 22:57:17.430 UTC [175] LOG:  statement: select version()
2023-07-06 22:57:17.433 UTC [175] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-06 22:57:17.459 UTC [175] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-06 22:57:17.465 UTC [175] LOG:  statement: select version()
2023-07-06 22:57:17.468 UTC [175] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-06 22:57:17.539 UTC [175] LOG:  statement: select version()
2023-07-06 22:57:17.557 UTC [175] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:57:17.598 UTC [175] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 22:57:17.598 UTC [175] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-06 22:57:17.659 UTC [175] LOG:  statement: select version()
2023-07-06 22:57:17.659 UTC [174] LOG:  statement: select version()
2023-07-06 22:57:17.666 UTC [174] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:57:17.668 UTC [175] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:57:17.674 UTC [175] LOG:  statement: select version()
2023-07-06 22:57:17.682 UTC [175] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:57:22.221 UTC [176] LOG:  execute s0: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2) LIMIT $3 OFFSET $4
2023-07-06 22:57:22.221 UTC [176] DETAIL:  parameters: $1 = '2025.1', $2 = '6', $3 = '1', $4 = '0'
2023-07-06 22:59:33.121 UTC [182] LOG:  execute s0: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2) LIMIT $3 OFFSET $4
2023-07-06 22:59:33.121 UTC [182] DETAIL:  parameters: $1 = '2025.1', $2 = '6', $3 = '1', $4 = '0'
2023-07-06 22:59:33.129 UTC [182] LOG:  statement: BEGIN
2023-07-06 22:59:33.133 UTC [182] LOG:  execute s1: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2) OFFSET $3
2023-07-06 22:59:33.133 UTC [182] DETAIL:  parameters: $1 = '2025.1', $2 = '6', $3 = '0'
2023-07-06 22:59:33.137 UTC [182] LOG:  execute s2: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."nome" = $1 AND "public"."Turma"."id_curso" = $2)
2023-07-06 22:59:33.137 UTC [182] DETAIL:  parameters: $1 = '2025.1', $2 = '6'
2023-07-06 22:59:33.142 UTC [182] LOG:  execute s3: DELETE FROM "public"."Turma" WHERE ("public"."Turma"."id" IN ($1) AND ("public"."Turma"."nome" = $2 AND "public"."Turma"."id_curso" = $3))
2023-07-06 22:59:33.142 UTC [182] DETAIL:  parameters: $1 = '8', $2 = '2025.1', $3 = '6'
2023-07-06 22:59:33.149 UTC [182] LOG:  statement: COMMIT
2023-07-06 22:59:39.918 UTC [183] LOG:  statement: select version()
2023-07-06 22:59:39.921 UTC [183] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-06 22:59:39.957 UTC [183] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-06 22:59:39.963 UTC [183] LOG:  statement: select version()
2023-07-06 22:59:39.966 UTC [183] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-06 22:59:39.967 UTC [184] LOG:  statement: select version()
2023-07-06 22:59:39.970 UTC [184] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-06 22:59:40.044 UTC [183] LOG:  statement: select version()
2023-07-06 22:59:40.059 UTC [184] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-06 22:59:40.061 UTC [183] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:59:40.102 UTC [183] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-06 22:59:40.102 UTC [183] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-06 22:59:40.150 UTC [183] LOG:  statement: select version()
2023-07-06 22:59:40.162 UTC [183] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:59:40.171 UTC [183] LOG:  statement: select version()
2023-07-06 22:59:40.182 UTC [183] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 22:59:40.393 UTC [185] LOG:  statement: select version()
2023-07-06 22:59:40.395 UTC [185] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-06 23:01:01.982 UTC [28] LOG:  checkpoint starting: time
2023-07-06 23:01:02.285 UTC [28] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.233 s, sync=0.007 s, total=0.304 s; sync files=3, longest=0.004 s, average=0.003 s; distance=0 kB, estimate=1 kB
2023-07-06 23:08:36.759 UTC [204] LOG:  execute s0: SELECT "public"."Turma"."id", "public"."Turma"."nome", "public"."Turma"."id_curso" FROM "public"."Turma" WHERE 1=1 OFFSET $1
2023-07-06 23:08:36.759 UTC [204] DETAIL:  parameters: $1 = '0'
2023-07-06 23:08:58.782 UTC [1] LOG:  received fast shutdown request
2023-07-06 23:08:58.788 UTC [1] LOG:  aborting any active transactions
2023-07-06 23:08:58.791 UTC [1] LOG:  background worker "logical replication launcher" (PID 33) exited with exit code 1
2023-07-06 23:08:58.794 UTC [28] LOG:  shutting down
2023-07-06 23:08:58.799 UTC [28] LOG:  checkpoint starting: shutdown immediate
2023-07-06 23:08:58.857 UTC [28] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.010 s, sync=0.001 s, total=0.063 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=1 kB
2023-07-06 23:08:58.903 UTC [1] LOG:  database system is shut down
