2023-07-05 18:21:29.098 UTC [1] LOG:  starting PostgreSQL 15.3 (Debian 15.3-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
2023-07-05 18:21:29.102 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2023-07-05 18:21:29.102 UTC [1] LOG:  listening on IPv6 address "::", port 5432
2023-07-05 18:21:29.121 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2023-07-05 18:21:29.202 UTC [30] LOG:  database system was shut down at 2023-07-05 14:48:19 UTC
2023-07-05 18:21:29.403 UTC [1] LOG:  database system is ready to accept connections
2023-07-05 18:26:29.300 UTC [28] LOG:  checkpoint starting: time
2023-07-05 18:26:29.422 UTC [28] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.027 s, sync=0.014 s, total=0.123 s; sync files=3, longest=0.007 s, average=0.005 s; distance=0 kB, estimate=0 kB
2023-07-05 22:22:27.205 UTC [311] LOG:  statement: SELECT CURRENT_SCHEMA() AS schema
2023-07-05 22:22:27.235 UTC [311] LOG:  statement: select version()
2023-07-05 22:22:27.241 UTC [311] LOG:  statement: 
	      SELECT      n.nspname as schema, t.typname as typename, t.oid::int4 as typeid
	      FROM        pg_type t
	      LEFT JOIN   pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	      WHERE       (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid))
	      AND     NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
	      AND     n.nspname NOT IN ('pg_catalog', 'information_schema');
	    
2023-07-05 22:22:27.321 UTC [311] LOG:  statement: select version()
2023-07-05 22:22:27.578 UTC [311] LOG:  execute <unnamed>: 
	    SELECT datname
	    FROM pg_database
	    WHERE datistemplate = $1
	    
	    ORDER BY datname
	  
2023-07-05 22:22:27.578 UTC [311] DETAIL:  parameters: $1 = 'f'
2023-07-05 22:22:27.828 UTC [312] LOG:  statement: select version()
2023-07-05 22:22:27.831 UTC [312] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:22:27.903 UTC [312] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:22:27.915 UTC [312] LOG:  statement: select version()
2023-07-05 22:22:27.918 UTC [312] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:22:27.996 UTC [312] LOG:  statement: select version()
2023-07-05 22:22:28.037 UTC [312] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:22:28.115 UTC [312] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:22:37.475 UTC [312] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:22:37.475 UTC [312] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:22:37.536 UTC [312] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 22:22:37.536 UTC [312] DETAIL:  parameters: $1 = 'Aluno', $2 = 'public'
2023-07-05 22:22:37.554 UTC [312] LOG:  statement: select version()
2023-07-05 22:22:37.557 UTC [312] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Aluno"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 22:22:37.667 UTC [312] LOG:  statement: select version()
2023-07-05 22:22:37.671 UTC [312] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:22:38.562 UTC [312] LOG:  statement: select version()
2023-07-05 22:22:38.564 UTC [311] LOG:  statement: select version()
2023-07-05 22:22:38.567 UTC [312] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:22:38.570 UTC [311] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:22:38.576 UTC [312] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:22:38.590 UTC [311] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:22:38.596 UTC [311] LOG:  statement: select version()
2023-07-05 22:22:38.599 UTC [311] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:22:38.674 UTC [311] LOG:  statement: select version()
2023-07-05 22:22:38.692 UTC [311] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:22:38.731 UTC [311] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:22:38.731 UTC [311] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:22:38.772 UTC [311] LOG:  statement: select version()
2023-07-05 22:22:38.772 UTC [312] LOG:  statement: select version()
2023-07-05 22:22:38.779 UTC [311] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:22:38.781 UTC [312] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:22:38.788 UTC [311] LOG:  statement: select version()
2023-07-05 22:22:38.796 UTC [311] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:22:42.346 UTC [314] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:22:42.346 UTC [314] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:22:42.362 UTC [314] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:22:42.362 UTC [314] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:22:42.374 UTC [314] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:22:42.374 UTC [314] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:22:42.384 UTC [314] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:22:42.384 UTC [314] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:22:42.385 UTC [314] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:22:42.385 UTC [314] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:22:42.389 UTC [314] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:22:42.389 UTC [314] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:22:42.395 UTC [314] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:22:42.395 UTC [314] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:22:42.502 UTC [314] LOG:  statement: BEGIN
2023-07-05 22:22:42.515 UTC [314] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 22:22:42.515 UTC [314] DETAIL:  parameters: $1 = '1', $2 = '0'
2023-07-05 22:22:42.526 UTC [314] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 22:22:42.526 UTC [314] DETAIL:  parameters: $1 = '4', $2 = '0'
2023-07-05 22:22:42.529 UTC [314] LOG:  statement: ROLLBACK
2023-07-05 22:23:14.687 UTC [316] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:23:14.687 UTC [316] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 22:23:14.723 UTC [316] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 22:23:14.723 UTC [316] DETAIL:  parameters: $1 = 'Turma', $2 = 'public'
2023-07-05 22:23:14.730 UTC [316] LOG:  statement: select version()
2023-07-05 22:23:14.733 UTC [316] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Turma"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 22:23:14.784 UTC [316] LOG:  statement: select version()
2023-07-05 22:23:14.800 UTC [316] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:25.002 UTC [316] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:23:25.002 UTC [316] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 22:23:25.023 UTC [316] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 22:23:25.023 UTC [316] DETAIL:  parameters: $1 = 'Curso', $2 = 'public'
2023-07-05 22:23:25.031 UTC [316] LOG:  statement: select version()
2023-07-05 22:23:25.034 UTC [316] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Curso"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 22:23:25.097 UTC [316] LOG:  statement: select version()
2023-07-05 22:23:25.104 UTC [316] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:34.061 UTC [314] LOG:  statement: SELECT 1
2023-07-05 22:23:34.064 UTC [314] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:23:34.064 UTC [314] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:23:34.067 UTC [314] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:23:34.067 UTC [314] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:23:34.070 UTC [314] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:23:34.070 UTC [314] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:23:34.172 UTC [314] LOG:  statement: BEGIN
2023-07-05 22:23:34.174 UTC [314] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 22:23:34.174 UTC [314] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-05 22:23:34.178 UTC [314] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 22:23:34.178 UTC [314] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-05 22:23:34.186 UTC [314] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-05 22:23:34.186 UTC [314] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $2 = 'john italo lucas lima', $3 = 'jhon_italo2@hotmail.com', $4 = '06806374352', $5 = 'M', $6 = '88999772728', $7 = '2023-07-05 22:23:34.182', $8 = '6', $9 = '6'
2023-07-05 22:23:34.190 UTC [314] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-05 22:23:34.190 UTC [314] DETAIL:  parameters: $1 = '80cfc9b9-0841-4876-b609-57dec47d1cfc', $2 = 'jhon_italo2@hotmail.com', $3 = '$2b$10$zFvsOvyyUVaWhkbdyTuzRu4fVkXwwo0IVdqm9hbI2i5imnTe5dIrq', $4 = 'aluno', $5 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:23:34.197 UTC [314] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:23:34.197 UTC [314] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $2 = '1', $3 = '0'
2023-07-05 22:23:34.199 UTC [314] LOG:  statement: COMMIT
2023-07-05 22:23:42.559 UTC [316] LOG:  statement: select version()
2023-07-05 22:23:42.566 UTC [316] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:23:42.586 UTC [316] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:23:42.731 UTC [318] LOG:  statement: select version()
2023-07-05 22:23:42.734 UTC [318] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:23:42.754 UTC [318] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:23:42.759 UTC [318] LOG:  statement: select version()
2023-07-05 22:23:42.761 UTC [318] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:23:42.825 UTC [316] LOG:  statement: select version()
2023-07-05 22:23:42.825 UTC [318] LOG:  statement: select version()
2023-07-05 22:23:42.866 UTC [318] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:42.868 UTC [316] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:42.919 UTC [316] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:23:42.919 UTC [316] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 22:23:42.941 UTC [318] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:23:42.941 UTC [318] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:23:42.949 UTC [316] LOG:  statement: select version()
2023-07-05 22:23:42.990 UTC [318] LOG:  statement: select version()
2023-07-05 22:23:43.004 UTC [316] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:43.072 UTC [318] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:43.087 UTC [316] LOG:  statement: select version()
2023-07-05 22:23:43.109 UTC [318] LOG:  statement: select version()
2023-07-05 22:23:43.133 UTC [316] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:43.134 UTC [318] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:43.245 UTC [319] LOG:  statement: select version()
2023-07-05 22:23:43.337 UTC [319] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:43.383 UTC [319] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:23:43.383 UTC [319] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 22:23:43.405 UTC [319] LOG:  statement: select version()
2023-07-05 22:23:43.407 UTC [316] LOG:  statement: select version()
2023-07-05 22:23:43.408 UTC [320] LOG:  statement: select version()
2023-07-05 22:23:43.412 UTC [319] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:43.414 UTC [316] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:43.414 UTC [320] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:43.421 UTC [319] LOG:  statement: select version()
2023-07-05 22:23:43.428 UTC [319] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:43.463 UTC [321] LOG:  statement: select version()
2023-07-05 22:23:43.465 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:23:48.693 UTC [321] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:23:48.693 UTC [321] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:23:48.722 UTC [321] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 22:23:48.722 UTC [321] DETAIL:  parameters: $1 = 'User', $2 = 'public'
2023-07-05 22:23:48.731 UTC [321] LOG:  statement: select version()
2023-07-05 22:23:48.733 UTC [321] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."User"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 22:23:48.790 UTC [321] LOG:  statement: select version()
2023-07-05 22:23:48.796 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:06.249 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:06.253 UTC [321] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:24:06.274 UTC [321] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:24:06.428 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:06.431 UTC [322] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:24:06.450 UTC [322] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:24:06.456 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:06.458 UTC [322] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:24:06.526 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:06.526 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:06.546 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:06.550 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:06.573 UTC [321] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:06.573 UTC [321] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 22:24:06.592 UTC [322] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:06.592 UTC [322] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:24:06.620 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:06.647 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:06.652 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:06.769 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:06.774 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:06.817 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:06.823 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:06.828 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:06.833 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:06.834 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:06.866 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:06.923 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:06.924 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:06.927 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:06.969 UTC [324] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:06.969 UTC [324] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:24:06.976 UTC [323] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:06.976 UTC [323] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 22:24:07.001 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:07.001 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:07.038 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:07.039 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:07.046 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:07.049 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:07.051 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:07.054 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:07.055 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:07.059 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:07.064 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:07.068 UTC [325] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:07.077 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:07.080 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:09.858 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:09.860 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:09.865 UTC [324] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:24:09.866 UTC [323] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:24:09.878 UTC [324] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:24:09.879 UTC [323] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:24:09.886 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:09.889 UTC [324] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:24:09.964 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:09.966 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:09.968 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:09.968 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:09.987 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:09.989 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:09.990 UTC [325] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:09.991 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.007 UTC [322] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:10.007 UTC [322] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:24:10.010 UTC [321] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:10.010 UTC [321] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 22:24:10.044 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:10.048 UTC [325] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:10.048 UTC [325] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 22:24:10.059 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:10.067 UTC [321] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:10.067 UTC [321] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:24:10.079 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:10.105 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:10.129 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:10.129 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:10.131 UTC [325] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.165 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.172 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:10.174 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:10.181 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.181 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.184 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:10.186 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.191 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.194 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.199 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:10.200 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.204 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:10.207 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.242 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:10.243 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.249 UTC [325] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:10.271 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:23.212 UTC [314] LOG:  statement: SELECT 1
2023-07-05 22:24:23.216 UTC [314] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:24:23.216 UTC [314] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:24:23.219 UTC [314] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:24:23.219 UTC [314] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:24:23.223 UTC [314] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:24:23.223 UTC [314] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:24:30.030 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:30.030 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:30.036 UTC [325] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:24:30.038 UTC [322] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:24:30.061 UTC [325] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:24:30.062 UTC [322] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:24:30.071 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:30.077 UTC [325] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:24:30.166 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:30.166 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:30.166 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:30.167 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:30.186 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.190 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.192 UTC [325] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.193 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.208 UTC [321] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:30.208 UTC [321] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:24:30.209 UTC [324] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:30.209 UTC [324] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 22:24:30.221 UTC [325] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:30.221 UTC [325] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:24:30.224 UTC [323] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:30.224 UTC [323] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 22:24:30.259 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:30.261 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:30.302 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:30.316 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:30.345 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:30.404 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.404 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:30.404 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.404 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:30.405 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:30.443 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.448 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.449 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.459 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:30.459 UTC [325] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.465 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.469 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.472 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:30.479 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:30.485 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:30.488 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.489 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.494 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.495 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.702 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:30.704 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:30.708 UTC [323] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:24:30.708 UTC [324] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:24:30.717 UTC [323] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:24:30.725 UTC [324] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:24:30.733 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:30.738 UTC [324] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:24:30.842 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:30.844 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:30.844 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:30.846 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:30.875 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.877 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.879 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.880 UTC [325] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:30.897 UTC [322] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:30.897 UTC [322] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 22:24:30.899 UTC [321] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:30.899 UTC [321] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 22:24:30.902 UTC [325] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:30.902 UTC [325] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:24:30.914 UTC [324] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:24:30.914 UTC [324] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:24:30.928 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:30.928 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:30.990 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:30.992 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:31.022 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:31.045 UTC [324] LOG:  statement: select version()
2023-07-05 22:24:31.047 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:31.050 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:31.052 UTC [325] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.054 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.055 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.057 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.059 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.059 UTC [325] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.065 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.111 UTC [324] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.130 UTC [325] LOG:  statement: select version()
2023-07-05 22:24:31.139 UTC [321] LOG:  statement: select version()
2023-07-05 22:24:31.145 UTC [322] LOG:  statement: select version()
2023-07-05 22:24:31.150 UTC [323] LOG:  statement: select version()
2023-07-05 22:24:31.152 UTC [325] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.155 UTC [321] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.158 UTC [322] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:31.160 UTC [323] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:24:35.996 UTC [314] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:24:35.996 UTC [314] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:24:36.003 UTC [314] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:24:36.003 UTC [314] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:24:36.007 UTC [314] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:24:36.007 UTC [314] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:26:34.734 UTC [28] LOG:  checkpoint starting: time
2023-07-05 22:26:35.526 UTC [28] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.726 s, sync=0.012 s, total=0.793 s; sync files=8, longest=0.004 s, average=0.002 s; distance=6 kB, estimate=6 kB
2023-07-05 22:26:42.831 UTC [333] LOG:  statement: select version()
2023-07-05 22:26:42.834 UTC [333] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:26:42.861 UTC [333] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:26:42.893 UTC [332] LOG:  statement: select version()
2023-07-05 22:26:42.896 UTC [332] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:26:42.926 UTC [332] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:26:42.931 UTC [332] LOG:  statement: select version()
2023-07-05 22:26:42.937 UTC [332] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:26:43.017 UTC [332] LOG:  statement: select version()
2023-07-05 22:26:43.047 UTC [332] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.097 UTC [332] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:26:43.097 UTC [332] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:26:43.287 UTC [332] LOG:  statement: select version()
2023-07-05 22:26:43.287 UTC [333] LOG:  statement: select version()
2023-07-05 22:26:43.295 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:43.297 UTC [333] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.298 UTC [332] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.300 UTC [336] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.301 UTC [335] LOG:  statement: select version()
2023-07-05 22:26:43.305 UTC [332] LOG:  statement: select version()
2023-07-05 22:26:43.307 UTC [335] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.310 UTC [332] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.377 UTC [336] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:26:43.377 UTC [336] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:26:43.379 UTC [335] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:26:43.379 UTC [335] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 22:26:43.432 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:43.432 UTC [332] LOG:  statement: select version()
2023-07-05 22:26:43.456 UTC [333] LOG:  statement: select version()
2023-07-05 22:26:43.457 UTC [335] LOG:  statement: select version()
2023-07-05 22:26:43.457 UTC [334] LOG:  statement: select version()
2023-07-05 22:26:43.462 UTC [336] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.462 UTC [332] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.464 UTC [333] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.466 UTC [335] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.467 UTC [334] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.473 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:43.481 UTC [335] LOG:  statement: select version()
2023-07-05 22:26:43.490 UTC [336] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.491 UTC [335] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.522 UTC [334] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:26:43.522 UTC [334] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 22:26:43.558 UTC [334] LOG:  statement: select version()
2023-07-05 22:26:43.560 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:43.562 UTC [334] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.563 UTC [336] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:43.568 UTC [334] LOG:  statement: select version()
2023-07-05 22:26:43.571 UTC [334] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:49.863 UTC [334] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:26:49.863 UTC [334] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:26:49.928 UTC [334] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 22:26:49.928 UTC [334] DETAIL:  parameters: $1 = 'User', $2 = 'public'
2023-07-05 22:26:49.935 UTC [334] LOG:  statement: select version()
2023-07-05 22:26:49.938 UTC [334] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."User"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 22:26:49.998 UTC [334] LOG:  statement: select version()
2023-07-05 22:26:50.010 UTC [334] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.167 UTC [334] LOG:  statement: select version()
2023-07-05 22:26:52.169 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:52.171 UTC [334] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:26:52.172 UTC [336] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:26:52.185 UTC [334] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:26:52.186 UTC [336] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:26:52.192 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:52.195 UTC [336] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:26:52.285 UTC [335] LOG:  statement: select version()
2023-07-05 22:26:52.286 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:52.287 UTC [333] LOG:  statement: select version()
2023-07-05 22:26:52.290 UTC [332] LOG:  statement: select version()
2023-07-05 22:26:52.307 UTC [335] LOG:  statement: select version()
2023-07-05 22:26:52.312 UTC [336] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.312 UTC [333] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.314 UTC [332] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.315 UTC [335] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.316 UTC [334] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.343 UTC [336] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:26:52.343 UTC [336] DETAIL:  parameters: $1 = 'public', $2 = 'Turma'
2023-07-05 22:26:52.347 UTC [334] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:26:52.347 UTC [334] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:26:52.353 UTC [332] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:26:52.353 UTC [332] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 22:26:52.355 UTC [335] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:26:52.355 UTC [335] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:26:52.369 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:52.371 UTC [334] LOG:  statement: select version()
2023-07-05 22:26:52.382 UTC [333] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:26:52.382 UTC [333] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:26:52.430 UTC [332] LOG:  statement: select version()
2023-07-05 22:26:52.450 UTC [335] LOG:  statement: select version()
2023-07-05 22:26:52.460 UTC [334] LOG:  statement: select version()
2023-07-05 22:26:52.462 UTC [332] LOG:  statement: select version()
2023-07-05 22:26:52.463 UTC [335] LOG:  statement: select version()
2023-07-05 22:26:52.467 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:52.468 UTC [333] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.491 UTC [333] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.503 UTC [334] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.504 UTC [332] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.506 UTC [335] LOG:  statement: select version()
2023-07-05 22:26:52.507 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:52.509 UTC [333] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.513 UTC [334] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.517 UTC [333] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.521 UTC [335] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.521 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:52.523 UTC [332] LOG:  statement: select version()
2023-07-05 22:26:52.530 UTC [333] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.545 UTC [332] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.545 UTC [334] LOG:  statement: select version()
2023-07-05 22:26:52.549 UTC [335] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.552 UTC [336] LOG:  statement: select version()
2023-07-05 22:26:52.553 UTC [333] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.557 UTC [334] LOG:  statement: select version()
2023-07-05 22:26:52.558 UTC [335] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Turma"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.614 UTC [336] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:26:52.614 UTC [334] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:27:01.744 UTC [314] LOG:  statement: SELECT 1
2023-07-05 22:27:01.747 UTC [314] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:27:01.747 UTC [314] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:27:01.750 UTC [314] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:27:01.750 UTC [314] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:27:01.753 UTC [314] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:27:01.753 UTC [314] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:27:23.892 UTC [338] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:27:23.892 UTC [338] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:27:23.903 UTC [338] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:27:23.903 UTC [338] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:27:23.908 UTC [338] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:27:23.908 UTC [338] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:27:23.916 UTC [338] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:27:23.916 UTC [338] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:27:23.919 UTC [338] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:27:23.919 UTC [338] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:27:23.923 UTC [338] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:27:23.923 UTC [338] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:27:23.931 UTC [338] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:27:23.931 UTC [338] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:28:06.912 UTC [340] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:28:06.912 UTC [340] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:28:06.926 UTC [340] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:28:06.926 UTC [340] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:28:06.930 UTC [340] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:28:06.930 UTC [340] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:28:06.939 UTC [340] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:28:06.939 UTC [340] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:28:06.940 UTC [340] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:28:06.940 UTC [340] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:28:06.944 UTC [340] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:28:06.944 UTC [340] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:28:06.954 UTC [340] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:28:06.954 UTC [340] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:28:44.997 UTC [343] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:28:44.997 UTC [343] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:28:45.007 UTC [343] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:28:45.007 UTC [343] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:28:45.016 UTC [343] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:28:45.016 UTC [343] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:28:45.023 UTC [343] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:28:45.023 UTC [343] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:28:45.025 UTC [343] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:28:45.025 UTC [343] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:28:45.031 UTC [343] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:28:45.031 UTC [343] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:28:45.039 UTC [343] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:28:45.039 UTC [343] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:28:45.159 UTC [343] LOG:  statement: BEGIN
2023-07-05 22:28:45.165 UTC [343] LOG:  execute s5: SELECT "public"."Aluno"."id" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1)
2023-07-05 22:28:45.165 UTC [343] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:28:45.173 UTC [343] LOG:  execute s6: UPDATE "public"."Aluno" SET "nome" = $1, "email" = $2, "sexo" = $3, "telefone" = $4, "id_turma" = $5, "id_curso" = $6 WHERE ("public"."Aluno"."id" IN ($7) AND ("public"."Aluno"."id" = $8 AND 1=1))
2023-07-05 22:28:45.173 UTC [343] DETAIL:  parameters: $1 = 'marcos', $2 = 'marcos2@gmail.com', $3 = 'F', $4 = '4321', $5 = '5', $6 = '3', $7 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $8 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:28:45.183 UTC [343] ERROR:  insert or update on table "Aluno" violates foreign key constraint "Aluno_id_turma_fkey"
2023-07-05 22:28:45.183 UTC [343] DETAIL:  Key (id_turma)=(5) is not present in table "Turma".
2023-07-05 22:28:45.183 UTC [343] STATEMENT:  UPDATE "public"."Aluno" SET "nome" = $1, "email" = $2, "sexo" = $3, "telefone" = $4, "id_turma" = $5, "id_curso" = $6 WHERE ("public"."Aluno"."id" IN ($7) AND ("public"."Aluno"."id" = $8 AND 1=1))
2023-07-05 22:28:45.189 UTC [343] LOG:  statement: ROLLBACK
2023-07-05 22:31:23.425 UTC [349] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:31:23.425 UTC [349] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:31:23.437 UTC [349] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:31:23.437 UTC [349] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:31:23.444 UTC [349] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:31:23.444 UTC [349] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:31:23.453 UTC [349] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:31:23.453 UTC [349] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:31:23.455 UTC [349] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:31:23.455 UTC [349] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:31:23.461 UTC [349] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:31:23.461 UTC [349] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:31:23.470 UTC [349] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:31:23.470 UTC [349] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:31:23.593 UTC [349] LOG:  statement: BEGIN
2023-07-05 22:31:23.596 UTC [349] LOG:  execute s5: SELECT "public"."Aluno"."id" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1)
2023-07-05 22:31:23.596 UTC [349] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:31:23.602 UTC [349] LOG:  execute s6: UPDATE "public"."Aluno" SET "nome" = $1, "email" = $2, "sexo" = $3, "telefone" = $4, "id_turma" = $5, "id_curso" = $6 WHERE ("public"."Aluno"."id" IN ($7) AND ("public"."Aluno"."id" = $8 AND 1=1))
2023-07-05 22:31:23.602 UTC [349] DETAIL:  parameters: $1 = 'marcos', $2 = 'marcos2@gmail.com', $3 = 'F', $4 = '4321', $5 = '5', $6 = '3', $7 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $8 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:31:23.609 UTC [349] ERROR:  insert or update on table "Aluno" violates foreign key constraint "Aluno_id_turma_fkey"
2023-07-05 22:31:23.609 UTC [349] DETAIL:  Key (id_turma)=(5) is not present in table "Turma".
2023-07-05 22:31:23.609 UTC [349] STATEMENT:  UPDATE "public"."Aluno" SET "nome" = $1, "email" = $2, "sexo" = $3, "telefone" = $4, "id_turma" = $5, "id_curso" = $6 WHERE ("public"."Aluno"."id" IN ($7) AND ("public"."Aluno"."id" = $8 AND 1=1))
2023-07-05 22:31:23.611 UTC [349] LOG:  statement: ROLLBACK
2023-07-05 22:31:34.633 UTC [28] LOG:  checkpoint starting: time
2023-07-05 22:31:34.795 UTC [28] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.115 s, sync=0.005 s, total=0.162 s; sync files=2, longest=0.004 s, average=0.003 s; distance=2 kB, estimate=5 kB
2023-07-05 22:35:40.696 UTC [358] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:35:40.696 UTC [358] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:35:40.708 UTC [358] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:35:40.708 UTC [358] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:35:40.714 UTC [358] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:35:40.714 UTC [358] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:35:40.722 UTC [358] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:35:40.722 UTC [358] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:35:40.725 UTC [358] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:35:40.725 UTC [358] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:35:40.730 UTC [358] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:35:40.730 UTC [358] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:35:40.738 UTC [358] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:35:40.738 UTC [358] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:35:40.873 UTC [358] LOG:  statement: BEGIN
2023-07-05 22:35:40.878 UTC [358] LOG:  execute s5: SELECT "public"."Aluno"."id" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1)
2023-07-05 22:35:40.878 UTC [358] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:35:40.883 UTC [358] LOG:  execute s6: UPDATE "public"."Aluno" SET "nome" = $1, "email" = $2, "sexo" = $3, "telefone" = $4, "id_turma" = $5, "id_curso" = $6 WHERE ("public"."Aluno"."id" IN ($7) AND ("public"."Aluno"."id" = $8 AND 1=1))
2023-07-05 22:35:40.883 UTC [358] DETAIL:  parameters: $1 = 'marcos', $2 = 'marcos2@gmail.com', $3 = 'F', $4 = '4321', $5 = '5', $6 = '3', $7 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $8 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:35:40.894 UTC [358] ERROR:  insert or update on table "Aluno" violates foreign key constraint "Aluno_id_turma_fkey"
2023-07-05 22:35:40.894 UTC [358] DETAIL:  Key (id_turma)=(5) is not present in table "Turma".
2023-07-05 22:35:40.894 UTC [358] STATEMENT:  UPDATE "public"."Aluno" SET "nome" = $1, "email" = $2, "sexo" = $3, "telefone" = $4, "id_turma" = $5, "id_curso" = $6 WHERE ("public"."Aluno"."id" IN ($7) AND ("public"."Aluno"."id" = $8 AND 1=1))
2023-07-05 22:35:40.896 UTC [358] LOG:  statement: ROLLBACK
2023-07-05 22:36:25.212 UTC [361] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:36:25.212 UTC [361] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:36:25.221 UTC [361] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:36:25.221 UTC [361] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:36:25.229 UTC [361] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:36:25.229 UTC [361] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:36:25.236 UTC [361] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:36:25.236 UTC [361] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:36:25.238 UTC [361] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:36:25.238 UTC [361] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:36:25.242 UTC [361] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:36:25.242 UTC [361] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:36:25.252 UTC [361] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:36:25.252 UTC [361] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:36:25.375 UTC [361] LOG:  statement: BEGIN
2023-07-05 22:36:25.380 UTC [361] LOG:  execute s5: SELECT "public"."Aluno"."id" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1)
2023-07-05 22:36:25.380 UTC [361] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:36:25.384 UTC [361] LOG:  execute s6: UPDATE "public"."Aluno" SET "nome" = $1, "email" = $2, "sexo" = $3, "telefone" = $4, "id_turma" = $5, "id_curso" = $6 WHERE ("public"."Aluno"."id" IN ($7) AND ("public"."Aluno"."id" = $8 AND 1=1))
2023-07-05 22:36:25.384 UTC [361] DETAIL:  parameters: $1 = 'marcos', $2 = 'marcos2@gmail.com', $3 = 'F', $4 = '4321', $5 = '6', $6 = '6', $7 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $8 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:36:25.392 UTC [361] LOG:  execute s7: SELECT "public"."User"."id", "public"."User"."id_aluno" FROM "public"."User" WHERE (("public"."User"."email" = $1 AND 1=1) AND "public"."User"."id_aluno" IN ($2)) OFFSET $3
2023-07-05 22:36:25.392 UTC [361] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $3 = '0'
2023-07-05 22:36:25.398 UTC [361] LOG:  execute s8: UPDATE "public"."User" SET "email" = $1, "password" = $2 WHERE ("public"."User"."id" IN ($3) AND ("public"."User"."email" = $4 AND 1=1))
2023-07-05 22:36:25.398 UTC [361] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '$2b$10$RJM.az.Jsxd2P5fdb.yaPOJHM7WCMoVfjNVqV9EBr/VJsowE/YlqK', $3 = '80cfc9b9-0841-4876-b609-57dec47d1cfc', $4 = 'jhon_italo2@hotmail.com'
2023-07-05 22:36:25.403 UTC [361] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:36:25.403 UTC [361] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $2 = '1', $3 = '0'
2023-07-05 22:36:25.405 UTC [361] LOG:  statement: COMMIT
2023-07-05 22:36:25.424 UTC [361] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:36:25.424 UTC [361] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:36:30.071 UTC [362] LOG:  statement: select version()
2023-07-05 22:36:30.074 UTC [362] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:30.096 UTC [362] LOG:  statement: select version()
2023-07-05 22:36:30.099 UTC [362] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:30.146 UTC [363] LOG:  statement: select version()
2023-07-05 22:36:30.149 UTC [363] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:30.165 UTC [363] LOG:  statement: select version()
2023-07-05 22:36:30.168 UTC [363] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:31.922 UTC [363] LOG:  statement: select version()
2023-07-05 22:36:31.923 UTC [362] LOG:  statement: select version()
2023-07-05 22:36:31.929 UTC [363] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:36:31.930 UTC [362] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:36:31.959 UTC [363] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:36:31.967 UTC [362] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:36:31.973 UTC [362] LOG:  statement: select version()
2023-07-05 22:36:31.976 UTC [362] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:36:32.052 UTC [362] LOG:  statement: select version()
2023-07-05 22:36:32.084 UTC [362] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.149 UTC [362] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:36:32.149 UTC [362] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:36:32.302 UTC [363] LOG:  statement: select version()
2023-07-05 22:36:32.302 UTC [362] LOG:  statement: select version()
2023-07-05 22:36:32.460 UTC [363] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.463 UTC [362] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.464 UTC [365] LOG:  statement: select version()
2023-07-05 22:36:32.477 UTC [362] LOG:  statement: select version()
2023-07-05 22:36:32.483 UTC [365] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.491 UTC [362] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.546 UTC [365] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:36:32.546 UTC [365] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:36:32.581 UTC [366] LOG:  statement: select version()
2023-07-05 22:36:32.623 UTC [365] LOG:  statement: select version()
2023-07-05 22:36:32.623 UTC [362] LOG:  statement: select version()
2023-07-05 22:36:32.623 UTC [363] LOG:  statement: select version()
2023-07-05 22:36:32.629 UTC [366] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.629 UTC [364] LOG:  statement: select version()
2023-07-05 22:36:32.631 UTC [363] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.632 UTC [365] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.634 UTC [362] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.637 UTC [364] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.653 UTC [365] LOG:  statement: select version()
2023-07-05 22:36:32.656 UTC [366] LOG:  statement: select version()
2023-07-05 22:36:32.659 UTC [362] LOG:  statement: select version()
2023-07-05 22:36:32.663 UTC [365] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.664 UTC [366] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.667 UTC [362] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.697 UTC [364] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:36:32.697 UTC [364] DETAIL:  parameters: $1 = 'public', $2 = 'Curso'
2023-07-05 22:36:32.714 UTC [362] LOG:  statement: select version()
2023-07-05 22:36:32.714 UTC [364] LOG:  statement: select version()
2023-07-05 22:36:32.716 UTC [364] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.717 UTC [362] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:32.721 UTC [364] LOG:  statement: select version()
2023-07-05 22:36:32.724 UTC [364] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Curso"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:34.892 UTC [28] LOG:  checkpoint starting: time
2023-07-05 22:36:35.364 UTC [28] LOG:  checkpoint complete: wrote 5 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.419 s, sync=0.008 s, total=0.473 s; sync files=5, longest=0.004 s, average=0.002 s; distance=5 kB, estimate=5 kB
2023-07-05 22:36:39.075 UTC [364] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:36:39.075 UTC [364] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:36:39.115 UTC [364] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 22:36:39.115 UTC [364] DETAIL:  parameters: $1 = 'User', $2 = 'public'
2023-07-05 22:36:39.122 UTC [364] LOG:  statement: select version()
2023-07-05 22:36:39.125 UTC [364] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."User"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 22:36:39.206 UTC [364] LOG:  statement: select version()
2023-07-05 22:36:39.213 UTC [364] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:44.688 UTC [364] LOG:  statement: select version()
2023-07-05 22:36:44.694 UTC [364] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:36:44.710 UTC [364] LOG:  statement: select version()
2023-07-05 22:36:44.722 UTC [364] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:40:00.680 UTC [361] LOG:  statement: SELECT 1
2023-07-05 22:40:00.684 UTC [361] LOG:  execute s10: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE 1=1 OFFSET $1
2023-07-05 22:40:00.684 UTC [361] DETAIL:  parameters: $1 = '0'
2023-07-05 22:40:04.997 UTC [361] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:40:04.997 UTC [361] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:40:08.536 UTC [361] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:40:08.536 UTC [361] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:40:18.749 UTC [361] LOG:  statement: SELECT 1
2023-07-05 22:40:18.751 UTC [361] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:40:18.751 UTC [361] DETAIL:  parameters: $1 = '068063743528', $2 = '1', $3 = '0'
2023-07-05 22:40:22.104 UTC [361] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:40:22.104 UTC [361] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:40:26.912 UTC [361] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:40:26.912 UTC [361] DETAIL:  parameters: $1 = 'marcos2@gmail.comh', $2 = '1', $3 = '0'
2023-07-05 22:40:29.938 UTC [361] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:40:29.938 UTC [361] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:40:34.147 UTC [361] LOG:  statement: SELECT 1
2023-07-05 22:40:34.149 UTC [361] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:40:34.149 UTC [361] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:40:34.153 UTC [361] LOG:  statement: BEGIN
2023-07-05 22:40:34.156 UTC [361] LOG:  execute s11: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 22:40:34.156 UTC [361] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:40:34.158 UTC [361] LOG:  statement: ROLLBACK
2023-07-05 22:41:49.784 UTC [361] LOG:  statement: SELECT 1
2023-07-05 22:41:49.786 UTC [361] LOG:  execute s10: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE 1=1 OFFSET $1
2023-07-05 22:41:49.786 UTC [361] DETAIL:  parameters: $1 = '0'
2023-07-05 22:41:53.134 UTC [361] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:41:53.134 UTC [361] DETAIL:  parameters: $1 = 'marcos2@gmail.com', $2 = '1', $3 = '0'
2023-07-05 22:42:00.175 UTC [361] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:42:00.175 UTC [361] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:42:00.178 UTC [361] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:42:00.178 UTC [361] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:44:36.929 UTC [383] LOG:  statement: select version()
2023-07-05 22:44:36.935 UTC [383] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:44:36.972 UTC [383] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:44:37.058 UTC [384] LOG:  statement: select version()
2023-07-05 22:44:37.062 UTC [384] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:44:37.103 UTC [384] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:44:37.116 UTC [384] LOG:  statement: select version()
2023-07-05 22:44:37.119 UTC [384] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:44:37.217 UTC [384] LOG:  statement: select version()
2023-07-05 22:44:37.250 UTC [384] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:44:37.320 UTC [384] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:44:37.320 UTC [384] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:44:37.482 UTC [384] LOG:  statement: select version()
2023-07-05 22:44:37.523 UTC [384] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:44:37.528 UTC [385] LOG:  statement: select version()
2023-07-05 22:44:37.555 UTC [385] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:44:37.572 UTC [384] LOG:  statement: select version()
2023-07-05 22:44:37.609 UTC [384] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:44:37.660 UTC [385] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:44:37.660 UTC [385] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:44:37.711 UTC [384] LOG:  statement: select version()
2023-07-05 22:44:37.712 UTC [385] LOG:  statement: select version()
2023-07-05 22:44:37.766 UTC [385] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:44:37.767 UTC [384] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:44:37.773 UTC [385] LOG:  statement: select version()
2023-07-05 22:44:37.777 UTC [385] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:44:37.861 UTC [386] LOG:  statement: select version()
2023-07-05 22:44:37.864 UTC [386] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:44:44.432 UTC [388] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:44:44.432 UTC [388] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:44:44.439 UTC [388] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:44:44.439 UTC [388] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:44:44.443 UTC [388] LOG:  execute s0: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:44:44.443 UTC [388] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:44:44.449 UTC [388] LOG:  statement: BEGIN
2023-07-05 22:44:44.452 UTC [388] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 22:44:44.452 UTC [388] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:44:44.454 UTC [388] LOG:  statement: ROLLBACK
2023-07-05 22:46:00.733 UTC [391] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:46:00.733 UTC [391] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:46:00.743 UTC [391] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:46:00.743 UTC [391] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:46:00.748 UTC [391] LOG:  execute s0: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:46:00.748 UTC [391] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:46:00.766 UTC [391] LOG:  statement: BEGIN
2023-07-05 22:46:00.771 UTC [391] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 22:46:00.771 UTC [391] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:46:00.773 UTC [391] LOG:  statement: ROLLBACK
2023-07-05 22:47:07.047 UTC [394] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:47:07.047 UTC [394] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:47:07.056 UTC [394] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:47:07.056 UTC [394] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:47:07.062 UTC [394] LOG:  execute s0: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:47:07.062 UTC [394] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:47:07.079 UTC [394] LOG:  statement: BEGIN
2023-07-05 22:47:07.084 UTC [394] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 22:47:07.084 UTC [394] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $2 = '1', $3 = '0'
2023-07-05 22:47:07.088 UTC [394] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:47:07.088 UTC [394] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:47:07.089 UTC [394] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:47:07.089 UTC [394] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:47:07.099 UTC [394] LOG:  execute s4: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."id_aluno" IN ($1) OFFSET $2
2023-07-05 22:47:07.099 UTC [394] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $2 = '0'
2023-07-05 22:47:07.103 UTC [394] LOG:  execute s5: SELECT "public"."Aluno"."id" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1)
2023-07-05 22:47:07.103 UTC [394] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:47:07.108 UTC [394] LOG:  execute s6: DELETE FROM "public"."Aluno" WHERE ("public"."Aluno"."id" IN ($1) AND ("public"."Aluno"."id" = $2 AND 1=1))
2023-07-05 22:47:07.108 UTC [394] DETAIL:  parameters: $1 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd', $2 = 'f766ae3c-30ea-4756-8e57-7ec54b6494cd'
2023-07-05 22:47:07.120 UTC [394] LOG:  statement: COMMIT
2023-07-05 22:49:30.457 UTC [400] LOG:  statement: select version()
2023-07-05 22:49:30.460 UTC [400] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:49:30.491 UTC [400] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:49:30.546 UTC [401] LOG:  statement: select version()
2023-07-05 22:49:30.549 UTC [401] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:49:30.579 UTC [401] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:49:30.585 UTC [401] LOG:  statement: select version()
2023-07-05 22:49:30.588 UTC [401] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:49:30.651 UTC [401] LOG:  statement: select version()
2023-07-05 22:49:30.676 UTC [401] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:30.719 UTC [401] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:49:30.719 UTC [401] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:49:30.840 UTC [400] LOG:  statement: select version()
2023-07-05 22:49:30.840 UTC [401] LOG:  statement: select version()
2023-07-05 22:49:30.847 UTC [402] LOG:  statement: select version()
2023-07-05 22:49:30.850 UTC [401] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:30.851 UTC [400] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:30.855 UTC [402] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:30.860 UTC [401] LOG:  statement: select version()
2023-07-05 22:49:30.870 UTC [401] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:30.909 UTC [402] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:49:30.909 UTC [402] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:49:30.929 UTC [401] LOG:  statement: select version()
2023-07-05 22:49:30.929 UTC [402] LOG:  statement: select version()
2023-07-05 22:49:30.932 UTC [402] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:30.933 UTC [401] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:30.938 UTC [402] LOG:  statement: select version()
2023-07-05 22:49:30.941 UTC [402] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:34.400 UTC [403] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:49:34.400 UTC [403] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:49:34.411 UTC [403] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:49:34.411 UTC [403] DETAIL:  parameters: $1 = '16537'
2023-07-05 22:49:34.415 UTC [403] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:49:34.415 UTC [403] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:49:34.423 UTC [403] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-05 22:49:34.423 UTC [403] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:49:34.425 UTC [403] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-05 22:49:34.425 UTC [403] DETAIL:  parameters: $1 = '16419'
2023-07-05 22:49:34.428 UTC [403] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:49:34.428 UTC [403] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:49:34.433 UTC [403] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:49:34.433 UTC [403] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:49:34.537 UTC [403] LOG:  statement: BEGIN
2023-07-05 22:49:34.545 UTC [403] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 22:49:34.545 UTC [403] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-05 22:49:34.552 UTC [403] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 22:49:34.552 UTC [403] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-05 22:49:34.557 UTC [403] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-05 22:49:34.557 UTC [403] DETAIL:  parameters: $1 = '723deec5-e2bd-44cc-88e6-030fc8c1a663', $2 = 'john italo lucas lima', $3 = 'jhon_italo2@hotmail.com', $4 = '06806374352', $5 = 'M', $6 = '88999772728', $7 = '2023-07-05 22:49:34.535', $8 = '6', $9 = '6'
2023-07-05 22:49:34.561 UTC [403] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-05 22:49:34.561 UTC [403] DETAIL:  parameters: $1 = '56a43065-eb96-4e50-a93a-79fdd85e27d0', $2 = 'jhon_italo2@hotmail.com', $3 = '$2b$10$Gw1y9LcETA1chShht8RGyepxglfJa4WMBxBYlULT2TZXlEQl4GsIy', $4 = 'aluno', $5 = '723deec5-e2bd-44cc-88e6-030fc8c1a663'
2023-07-05 22:49:34.566 UTC [403] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:49:34.566 UTC [403] DETAIL:  parameters: $1 = '723deec5-e2bd-44cc-88e6-030fc8c1a663', $2 = '1', $3 = '0'
2023-07-05 22:49:34.568 UTC [403] LOG:  statement: COMMIT
2023-07-05 22:49:37.492 UTC [403] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:49:37.492 UTC [403] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:49:37.505 UTC [403] LOG:  statement: BEGIN
2023-07-05 22:49:37.510 UTC [403] LOG:  execute s10: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 22:49:37.510 UTC [403] DETAIL:  parameters: $1 = '723deec5-e2bd-44cc-88e6-030fc8c1a663', $2 = '1', $3 = '0'
2023-07-05 22:49:37.514 UTC [403] LOG:  execute s11: SELECT "public"."Aluno"."id" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1)
2023-07-05 22:49:37.514 UTC [403] DETAIL:  parameters: $1 = '723deec5-e2bd-44cc-88e6-030fc8c1a663'
2023-07-05 22:49:37.522 UTC [403] LOG:  execute s12: DELETE FROM "public"."Aluno" WHERE ("public"."Aluno"."id" IN ($1) AND ("public"."Aluno"."id" = $2 AND 1=1))
2023-07-05 22:49:37.522 UTC [403] DETAIL:  parameters: $1 = '723deec5-e2bd-44cc-88e6-030fc8c1a663', $2 = '723deec5-e2bd-44cc-88e6-030fc8c1a663'
2023-07-05 22:49:37.529 UTC [403] LOG:  statement: COMMIT
2023-07-05 22:49:53.655 UTC [405] LOG:  statement: select version()
2023-07-05 22:49:53.658 UTC [405] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:49:53.684 UTC [405] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:49:53.691 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:53.694 UTC [406] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:49:53.721 UTC [406] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:49:53.726 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:53.729 UTC [406] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:49:53.796 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:53.820 UTC [406] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:53.890 UTC [406] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:49:53.890 UTC [406] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:49:54.012 UTC [405] LOG:  statement: select version()
2023-07-05 22:49:54.012 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:54.021 UTC [406] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:54.023 UTC [407] LOG:  statement: select version()
2023-07-05 22:49:54.026 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:54.030 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:54.032 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:54.040 UTC [406] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:54.078 UTC [407] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:49:54.078 UTC [407] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:49:54.096 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:54.096 UTC [407] LOG:  statement: select version()
2023-07-05 22:49:54.099 UTC [406] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:54.099 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:54.105 UTC [407] LOG:  statement: select version()
2023-07-05 22:49:54.109 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:55.737 UTC [407] LOG:  statement: select version()
2023-07-05 22:49:55.739 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:55.743 UTC [407] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:49:55.743 UTC [406] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:49:55.753 UTC [406] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:49:55.757 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:55.760 UTC [406] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:49:55.805 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:55.805 UTC [405] LOG:  statement: select version()
2023-07-05 22:49:55.823 UTC [407] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:49:55.826 UTC [406] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:55.827 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:55.840 UTC [406] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:49:55.840 UTC [406] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:49:55.875 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:55.877 UTC [405] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:49:55.877 UTC [405] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:49:55.878 UTC [406] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:55.886 UTC [406] LOG:  statement: select version()
2023-07-05 22:49:55.940 UTC [405] LOG:  statement: select version()
2023-07-05 22:49:55.948 UTC [406] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:55.955 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:56.038 UTC [405] LOG:  statement: select version()
2023-07-05 22:49:56.060 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:56.152 UTC [408] LOG:  statement: select version()
2023-07-05 22:49:56.158 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:56.229 UTC [409] LOG:  statement: select version()
2023-07-05 22:49:56.232 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:49:58.757 UTC [403] LOG:  statement: SELECT 1
2023-07-05 22:49:58.758 UTC [403] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:49:58.758 UTC [403] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:49:58.762 UTC [403] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:49:58.762 UTC [403] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:49:58.766 UTC [403] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:49:58.766 UTC [403] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:49:58.873 UTC [403] LOG:  statement: BEGIN
2023-07-05 22:49:58.876 UTC [403] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 22:49:58.876 UTC [403] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-05 22:49:58.877 UTC [403] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 22:49:58.877 UTC [403] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-05 22:49:58.879 UTC [403] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-05 22:49:58.879 UTC [403] DETAIL:  parameters: $1 = '031443db-2282-4752-8910-a1ab64b78731', $2 = 'john italo lucas lima', $3 = 'jhon_italo2@hotmail.com', $4 = '06806374352', $5 = 'M', $6 = '88999772728', $7 = '2023-07-05 22:49:58.874', $8 = '6', $9 = '6'
2023-07-05 22:49:58.882 UTC [403] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-05 22:49:58.882 UTC [403] DETAIL:  parameters: $1 = '997dade9-0229-4a12-8270-14cff49b52cc', $2 = 'jhon_italo2@hotmail.com', $3 = '$2b$10$7bglriaoZDkqv7ZT4J04ye1KcpAGYydBoQggiaAHQnkOSVW7btGW6', $4 = 'aluno', $5 = '031443db-2282-4752-8910-a1ab64b78731'
2023-07-05 22:49:58.885 UTC [403] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:49:58.885 UTC [403] DETAIL:  parameters: $1 = '031443db-2282-4752-8910-a1ab64b78731', $2 = '1', $3 = '0'
2023-07-05 22:49:58.887 UTC [403] LOG:  statement: COMMIT
2023-07-05 22:50:01.231 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:01.235 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:01.237 UTC [409] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:50:01.237 UTC [408] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:50:01.258 UTC [409] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:50:01.284 UTC [408] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:50:01.290 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:01.292 UTC [408] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:50:01.365 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:01.365 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:01.411 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:01.411 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:01.439 UTC [405] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:01.439 UTC [405] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:50:01.463 UTC [408] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:01.463 UTC [408] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:50:01.510 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:01.510 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:01.545 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:01.546 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:01.547 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:01.549 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:01.552 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:01.553 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:01.559 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:01.570 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:01.573 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:01.575 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:03.377 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:03.379 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:03.381 UTC [408] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:50:03.382 UTC [405] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:50:03.396 UTC [405] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:50:03.396 UTC [408] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:50:03.402 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:03.404 UTC [405] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:50:03.460 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:03.460 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:03.506 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:03.507 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:03.576 UTC [407] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:03.576 UTC [407] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:50:03.578 UTC [405] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:03.578 UTC [405] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:50:03.602 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:03.602 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:03.648 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:03.648 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:03.656 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:03.658 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:03.660 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:03.662 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:03.669 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:03.673 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:03.680 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:03.680 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:08.942 UTC [403] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:50:08.942 UTC [403] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:50:08.952 UTC [403] LOG:  statement: BEGIN
2023-07-05 22:50:08.955 UTC [403] LOG:  execute s10: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1) LIMIT $2 OFFSET $3
2023-07-05 22:50:08.955 UTC [403] DETAIL:  parameters: $1 = '031443db-2282-4752-8910-a1ab64b78731', $2 = '1', $3 = '0'
2023-07-05 22:50:08.957 UTC [403] LOG:  execute s11: SELECT "public"."Aluno"."id" FROM "public"."Aluno" WHERE ("public"."Aluno"."id" = $1 AND 1=1)
2023-07-05 22:50:08.957 UTC [403] DETAIL:  parameters: $1 = '031443db-2282-4752-8910-a1ab64b78731'
2023-07-05 22:50:08.959 UTC [403] LOG:  execute s12: DELETE FROM "public"."Aluno" WHERE ("public"."Aluno"."id" IN ($1) AND ("public"."Aluno"."id" = $2 AND 1=1))
2023-07-05 22:50:08.959 UTC [403] DETAIL:  parameters: $1 = '031443db-2282-4752-8910-a1ab64b78731', $2 = '031443db-2282-4752-8910-a1ab64b78731'
2023-07-05 22:50:08.961 UTC [403] LOG:  statement: COMMIT
2023-07-05 22:50:11.857 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:11.859 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:11.861 UTC [407] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:50:11.863 UTC [405] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:50:11.869 UTC [407] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:50:11.878 UTC [405] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:50:11.885 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:11.888 UTC [405] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:50:11.959 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:11.959 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:11.981 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:11.986 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:12.010 UTC [405] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:12.010 UTC [405] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:50:12.030 UTC [409] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:12.030 UTC [409] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:50:12.068 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:12.068 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:12.103 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:12.104 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:12.110 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:12.112 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:12.118 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:12.119 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:12.123 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:12.137 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:12.138 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:12.143 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:14.009 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:14.009 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:14.012 UTC [409] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:50:14.014 UTC [405] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:50:14.021 UTC [409] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:50:14.026 UTC [405] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:50:14.037 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:14.041 UTC [405] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:50:14.102 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:14.103 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:14.146 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:14.148 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:14.185 UTC [408] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:14.185 UTC [408] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:50:14.191 UTC [405] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:14.191 UTC [405] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:50:14.238 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:14.238 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:14.275 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:14.275 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:14.286 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:14.288 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:14.293 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:14.293 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:14.304 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:14.320 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:14.325 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:14.329 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:17.182 UTC [403] LOG:  statement: SELECT 1
2023-07-05 22:50:17.185 UTC [403] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:50:17.185 UTC [403] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:50:17.189 UTC [403] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:50:17.189 UTC [403] DETAIL:  parameters: $1 = '06806374352', $2 = '1', $3 = '0'
2023-07-05 22:50:17.193 UTC [403] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:50:17.193 UTC [403] DETAIL:  parameters: $1 = 'jhon_italo2@hotmail.com', $2 = '1', $3 = '0'
2023-07-05 22:50:17.297 UTC [403] LOG:  statement: BEGIN
2023-07-05 22:50:17.298 UTC [403] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 22:50:17.298 UTC [403] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-05 22:50:17.301 UTC [403] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-05 22:50:17.301 UTC [403] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-05 22:50:17.303 UTC [403] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-05 22:50:17.303 UTC [403] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = 'john italo lucas lima', $3 = 'jhon_italo2@hotmail.com', $4 = '06806374352', $5 = 'M', $6 = '88999772728', $7 = '2023-07-05 22:50:17.296', $8 = '6', $9 = '6'
2023-07-05 22:50:17.305 UTC [403] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-05 22:50:17.305 UTC [403] DETAIL:  parameters: $1 = '65c84055-b3a2-4c89-9b0b-49d9edb623ef', $2 = 'jhon_italo2@hotmail.com', $3 = '$2b$10$T4XeGXT2hei41r7dVTFoMubA6OPudQAsLOSHCXZkKukLd4VbWWACW', $4 = 'aluno', $5 = '49fa7012-7adb-41d9-a6b0-a951e3cab351'
2023-07-05 22:50:17.307 UTC [403] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-05 22:50:17.307 UTC [403] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '1', $3 = '0'
2023-07-05 22:50:17.309 UTC [403] LOG:  statement: COMMIT
2023-07-05 22:50:20.202 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:20.202 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:20.207 UTC [408] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:50:20.209 UTC [405] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:50:20.216 UTC [405] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:50:20.222 UTC [408] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:50:20.227 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:20.231 UTC [408] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:50:20.296 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:20.296 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:20.314 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:20.318 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:20.328 UTC [408] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:20.328 UTC [408] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:50:20.348 UTC [407] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:20.348 UTC [407] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:50:20.398 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:20.398 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:20.422 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:20.422 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:20.425 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:20.426 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:20.428 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:20.428 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:20.432 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:20.452 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:20.453 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:20.455 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:23.282 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:23.285 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:23.287 UTC [407] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 22:50:23.288 UTC [408] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 22:50:23.293 UTC [407] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 22:50:23.298 UTC [408] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 22:50:23.305 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:23.307 UTC [408] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 22:50:23.359 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:23.360 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:23.381 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:23.383 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:23.397 UTC [408] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:23.397 UTC [408] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 22:50:23.401 UTC [409] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 22:50:23.401 UTC [409] DETAIL:  parameters: $1 = 'public', $2 = 'User'
2023-07-05 22:50:23.425 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:23.426 UTC [407] LOG:  statement: select version()
2023-07-05 22:50:23.459 UTC [405] LOG:  statement: select version()
2023-07-05 22:50:23.459 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:23.466 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:23.467 UTC [407] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:23.470 UTC [405] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:23.471 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:23.475 UTC [408] LOG:  statement: select version()
2023-07-05 22:50:23.509 UTC [409] LOG:  statement: select version()
2023-07-05 22:50:23.509 UTC [408] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:50:23.523 UTC [409] LOG:  statement: 
	    SELECT * 
	    FROM "public"."User"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 22:51:34.605 UTC [28] LOG:  checkpoint starting: time
2023-07-05 22:51:35.386 UTC [28] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.723 s, sync=0.013 s, total=0.781 s; sync files=8, longest=0.004 s, average=0.002 s; distance=10 kB, estimate=10 kB
2023-07-05 23:00:24.230 UTC [431] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:00:24.230 UTC [431] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:00:24.266 UTC [431] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 23:00:24.266 UTC [431] DETAIL:  parameters: $1 = 'Disciplina', $2 = 'public'
2023-07-05 23:00:24.269 UTC [431] LOG:  statement: select version()
2023-07-05 23:00:24.273 UTC [431] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Disciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 23:00:24.339 UTC [431] LOG:  statement: select version()
2023-07-05 23:00:24.344 UTC [431] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:05:27.147 UTC [442] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:05:27.147 UTC [442] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:05:27.155 UTC [442] LOG:  statement: BEGIN
2023-07-05 23:05:27.170 UTC [442] LOG:  execute s1: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:05:27.170 UTC [442] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '1'
2023-07-05 23:05:27.194 UTC [442] ERROR:  insert or update on table "AlunoDisciplina" violates foreign key constraint "AlunoDisciplina_id_aluno_fkey"
2023-07-05 23:05:27.194 UTC [442] DETAIL:  Key (id_aluno)=(5e1c0ff2-829c-415b-9c75-caceff0b2a9e) is not present in table "Aluno".
2023-07-05 23:05:27.194 UTC [442] STATEMENT:  INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:05:27.234 UTC [442] LOG:  statement: ROLLBACK
2023-07-05 23:05:33.754 UTC [443] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:05:33.754 UTC [443] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:05:33.790 UTC [443] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 23:05:33.790 UTC [443] DETAIL:  parameters: $1 = 'AlunoDisciplina', $2 = 'public'
2023-07-05 23:05:33.797 UTC [443] LOG:  statement: select version()
2023-07-05 23:05:33.801 UTC [443] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."AlunoDisciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 23:05:33.848 UTC [443] LOG:  statement: select version()
2023-07-05 23:05:33.851 UTC [443] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:05:35.363 UTC [443] LOG:  statement: select version()
2023-07-05 23:05:35.369 UTC [443] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:05:35.391 UTC [443] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:05:35.537 UTC [444] LOG:  statement: select version()
2023-07-05 23:05:35.539 UTC [444] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:05:35.560 UTC [444] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:05:35.564 UTC [444] LOG:  statement: select version()
2023-07-05 23:05:35.567 UTC [444] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:05:35.610 UTC [444] LOG:  statement: select version()
2023-07-05 23:05:35.626 UTC [444] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:05:35.651 UTC [444] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:05:35.651 UTC [444] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:05:35.674 UTC [443] LOG:  statement: select version()
2023-07-05 23:05:35.674 UTC [444] LOG:  statement: select version()
2023-07-05 23:05:35.680 UTC [444] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:05:35.683 UTC [443] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:05:35.688 UTC [444] LOG:  statement: select version()
2023-07-05 23:05:35.695 UTC [444] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:05:39.781 UTC [444] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:05:39.781 UTC [444] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:05:39.811 UTC [444] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 23:05:39.811 UTC [444] DETAIL:  parameters: $1 = 'Disciplina', $2 = 'public'
2023-07-05 23:05:39.815 UTC [444] LOG:  statement: select version()
2023-07-05 23:05:39.818 UTC [444] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Disciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 23:05:39.892 UTC [444] LOG:  statement: select version()
2023-07-05 23:05:39.914 UTC [444] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:05:43.631 UTC [444] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:05:43.631 UTC [444] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:05:43.650 UTC [444] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 23:05:43.650 UTC [444] DETAIL:  parameters: $1 = 'AlunoDisciplina', $2 = 'public'
2023-07-05 23:05:43.657 UTC [444] LOG:  statement: select version()
2023-07-05 23:05:43.660 UTC [444] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."AlunoDisciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 23:05:43.717 UTC [444] LOG:  statement: select version()
2023-07-05 23:05:43.720 UTC [444] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:06:20.715 UTC [447] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:06:20.715 UTC [447] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:06:20.721 UTC [447] LOG:  statement: BEGIN
2023-07-05 23:06:20.737 UTC [447] LOG:  execute s1: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:06:20.737 UTC [447] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '1'
2023-07-05 23:06:20.740 UTC [447] ERROR:  insert or update on table "AlunoDisciplina" violates foreign key constraint "AlunoDisciplina_id_aluno_fkey"
2023-07-05 23:06:20.740 UTC [447] DETAIL:  Key (id_aluno)=(5e1c0ff2-829c-415b-9c75-caceff0b2a9e) is not present in table "Aluno".
2023-07-05 23:06:20.740 UTC [447] STATEMENT:  INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:06:20.770 UTC [447] LOG:  statement: ROLLBACK
2023-07-05 23:06:34.672 UTC [28] LOG:  checkpoint starting: time
2023-07-05 23:06:35.042 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.318 s, sync=0.009 s, total=0.371 s; sync files=4, longest=0.004 s, average=0.002 s; distance=2 kB, estimate=9 kB
2023-07-05 23:07:06.658 UTC [449] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:07:06.658 UTC [449] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:07:06.664 UTC [449] LOG:  statement: BEGIN
2023-07-05 23:07:06.681 UTC [449] LOG:  execute s1: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:07:06.681 UTC [449] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '1'
2023-07-05 23:07:06.687 UTC [449] ERROR:  insert or update on table "AlunoDisciplina" violates foreign key constraint "AlunoDisciplina_id_aluno_fkey"
2023-07-05 23:07:06.687 UTC [449] DETAIL:  Key (id_aluno)=(5e1c0ff2-829c-415b-9c75-caceff0b2a9e) is not present in table "Aluno".
2023-07-05 23:07:06.687 UTC [449] STATEMENT:  INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:07:06.715 UTC [449] LOG:  statement: ROLLBACK
2023-07-05 23:07:18.682 UTC [449] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:07:18.682 UTC [449] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:07:18.689 UTC [449] LOG:  statement: BEGIN
2023-07-05 23:07:18.696 UTC [449] LOG:  execute s1: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:07:18.696 UTC [449] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '2'
2023-07-05 23:07:18.696 UTC [449] ERROR:  insert or update on table "AlunoDisciplina" violates foreign key constraint "AlunoDisciplina_id_aluno_fkey"
2023-07-05 23:07:18.696 UTC [449] DETAIL:  Key (id_aluno)=(5e1c0ff2-829c-415b-9c75-caceff0b2a9e) is not present in table "Aluno".
2023-07-05 23:07:18.696 UTC [449] STATEMENT:  INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:07:18.701 UTC [449] LOG:  statement: ROLLBACK
2023-07-05 23:10:59.945 UTC [458] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:10:59.945 UTC [458] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:10:59.967 UTC [458] LOG:  statement: BEGIN
2023-07-05 23:10:59.984 UTC [458] LOG:  execute s1: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:10:59.984 UTC [458] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '2'
2023-07-05 23:11:00.000 UTC [458] ERROR:  insert or update on table "AlunoDisciplina" violates foreign key constraint "AlunoDisciplina_id_aluno_fkey"
2023-07-05 23:11:00.000 UTC [458] DETAIL:  Key (id_aluno)=(5e1c0ff2-829c-415b-9c75-caceff0b2a9e) is not present in table "Aluno".
2023-07-05 23:11:00.000 UTC [458] STATEMENT:  INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:11:00.055 UTC [458] LOG:  statement: ROLLBACK
2023-07-05 23:11:06.526 UTC [459] LOG:  statement: select version()
2023-07-05 23:11:06.529 UTC [459] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:11:06.556 UTC [459] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:11:06.580 UTC [460] LOG:  statement: select version()
2023-07-05 23:11:06.583 UTC [460] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:11:06.608 UTC [460] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:11:06.614 UTC [460] LOG:  statement: select version()
2023-07-05 23:11:06.616 UTC [460] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:11:06.688 UTC [460] LOG:  statement: select version()
2023-07-05 23:11:06.715 UTC [460] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:06.763 UTC [460] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:11:06.763 UTC [460] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:11:06.926 UTC [460] LOG:  statement: select version()
2023-07-05 23:11:06.927 UTC [459] LOG:  statement: select version()
2023-07-05 23:11:06.935 UTC [462] LOG:  statement: select version()
2023-07-05 23:11:06.940 UTC [459] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:06.942 UTC [460] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:06.945 UTC [462] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:06.949 UTC [460] LOG:  statement: select version()
2023-07-05 23:11:06.964 UTC [459] LOG:  statement: select version()
2023-07-05 23:11:06.973 UTC [460] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:06.979 UTC [459] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:06.980 UTC [461] LOG:  statement: select version()
2023-07-05 23:11:06.999 UTC [461] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:07.010 UTC [461] LOG:  statement: select version()
2023-07-05 23:11:07.021 UTC [462] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:11:07.021 UTC [462] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:11:07.052 UTC [461] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:07.071 UTC [462] LOG:  statement: select version()
2023-07-05 23:11:07.071 UTC [459] LOG:  statement: select version()
2023-07-05 23:11:07.105 UTC [459] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:07.106 UTC [462] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:07.148 UTC [462] LOG:  statement: select version()
2023-07-05 23:11:07.158 UTC [462] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:07.207 UTC [463] LOG:  statement: select version()
2023-07-05 23:11:07.210 UTC [463] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:11:34.136 UTC [28] LOG:  checkpoint starting: time
2023-07-05 23:11:34.504 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.318 s, sync=0.007 s, total=0.369 s; sync files=4, longest=0.004 s, average=0.002 s; distance=2 kB, estimate=8 kB
2023-07-05 23:12:13.289 UTC [467] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:12:13.289 UTC [467] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:12:13.296 UTC [467] LOG:  statement: BEGIN
2023-07-05 23:12:13.314 UTC [467] LOG:  execute s1: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:12:13.314 UTC [467] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '2'
2023-07-05 23:12:13.320 UTC [467] ERROR:  insert or update on table "AlunoDisciplina" violates foreign key constraint "AlunoDisciplina_id_aluno_fkey"
2023-07-05 23:12:13.320 UTC [467] DETAIL:  Key (id_aluno)=(5e1c0ff2-829c-415b-9c75-caceff0b2a9e) is not present in table "Aluno".
2023-07-05 23:12:13.320 UTC [467] STATEMENT:  INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:12:13.349 UTC [467] LOG:  statement: ROLLBACK
2023-07-05 23:13:19.763 UTC [470] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:13:19.763 UTC [470] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:13:19.771 UTC [470] LOG:  statement: BEGIN
2023-07-05 23:13:19.792 UTC [470] LOG:  execute s1: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:13:19.792 UTC [470] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '2'
2023-07-05 23:13:19.796 UTC [470] ERROR:  insert or update on table "AlunoDisciplina" violates foreign key constraint "AlunoDisciplina_id_aluno_fkey"
2023-07-05 23:13:19.796 UTC [470] DETAIL:  Key (id_aluno)=(5e1c0ff2-829c-415b-9c75-caceff0b2a9e) is not present in table "Aluno".
2023-07-05 23:13:19.796 UTC [470] STATEMENT:  INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:13:19.833 UTC [470] LOG:  statement: ROLLBACK
2023-07-05 23:13:23.000 UTC [471] LOG:  statement: select version()
2023-07-05 23:13:23.003 UTC [471] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:13:23.040 UTC [471] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:13:23.111 UTC [472] LOG:  statement: select version()
2023-07-05 23:13:23.115 UTC [472] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:13:23.144 UTC [472] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:13:23.150 UTC [472] LOG:  statement: select version()
2023-07-05 23:13:23.153 UTC [472] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:13:23.241 UTC [472] LOG:  statement: select version()
2023-07-05 23:13:23.272 UTC [472] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.329 UTC [472] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:13:23.329 UTC [472] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:13:23.473 UTC [472] LOG:  statement: select version()
2023-07-05 23:13:23.474 UTC [471] LOG:  statement: select version()
2023-07-05 23:13:23.548 UTC [472] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.549 UTC [471] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.551 UTC [473] LOG:  statement: select version()
2023-07-05 23:13:23.557 UTC [472] LOG:  statement: select version()
2023-07-05 23:13:23.561 UTC [473] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.582 UTC [471] LOG:  statement: select version()
2023-07-05 23:13:23.590 UTC [472] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.595 UTC [471] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.596 UTC [473] LOG:  statement: select version()
2023-07-05 23:13:23.680 UTC [473] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.687 UTC [474] LOG:  statement: select version()
2023-07-05 23:13:23.708 UTC [474] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.755 UTC [474] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:13:23.755 UTC [474] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:13:23.779 UTC [474] LOG:  statement: select version()
2023-07-05 23:13:23.779 UTC [473] LOG:  statement: select version()
2023-07-05 23:13:23.782 UTC [473] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.783 UTC [474] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.789 UTC [474] LOG:  statement: select version()
2023-07-05 23:13:23.793 UTC [475] LOG:  statement: select version()
2023-07-05 23:13:23.794 UTC [474] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:13:23.797 UTC [475] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:16.009 UTC [480] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:16.009 UTC [480] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:15:16.043 UTC [480] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 23:15:16.043 UTC [480] DETAIL:  parameters: $1 = 'AlunoDisciplina', $2 = 'public'
2023-07-05 23:15:16.051 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:16.053 UTC [480] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."AlunoDisciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 23:15:16.137 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:16.143 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:16.964 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:16.969 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:16.982 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:16.985 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:24.814 UTC [480] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:24.814 UTC [480] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 23:15:24.843 UTC [480] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 23:15:24.843 UTC [480] DETAIL:  parameters: $1 = 'Aluno', $2 = 'public'
2023-07-05 23:15:24.852 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:24.854 UTC [480] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Aluno"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 23:15:24.918 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:24.926 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:36.869 UTC [480] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:36.869 UTC [480] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:15:36.893 UTC [480] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-05 23:15:36.893 UTC [480] DETAIL:  parameters: $1 = 'Disciplina', $2 = 'public'
2023-07-05 23:15:36.899 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:36.901 UTC [480] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Disciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-05 23:15:36.935 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:36.947 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:43.956 UTC [480] LOG:  statement: BEGIN
2023-07-05 23:15:43.963 UTC [480] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:43.963 UTC [480] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:15:43.975 UTC [480] LOG:  statement: insert into "public"."AlunoDisciplina" ("id_aluno", "id_disciplina") values ('49fa7012-7adb-41d9-a6b0-a951e3cab351', '1')
2023-07-05 23:15:43.980 UTC [480] LOG:  statement: 
2023-07-05 23:15:43.983 UTC [480] LOG:  statement: 
2023-07-05 23:15:43.985 UTC [480] LOG:  statement: 
2023-07-05 23:15:43.988 UTC [480] LOG:  statement: COMMIT
2023-07-05 23:15:44.012 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:44.024 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:50.756 UTC [482] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:15:50.756 UTC [482] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:15:50.763 UTC [482] LOG:  statement: BEGIN
2023-07-05 23:15:50.779 UTC [482] LOG:  execute s1: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:15:50.779 UTC [482] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '2'
2023-07-05 23:15:50.781 UTC [482] ERROR:  insert or update on table "AlunoDisciplina" violates foreign key constraint "AlunoDisciplina_id_aluno_fkey"
2023-07-05 23:15:50.781 UTC [482] DETAIL:  Key (id_aluno)=(5e1c0ff2-829c-415b-9c75-caceff0b2a9e) is not present in table "Aluno".
2023-07-05 23:15:50.781 UTC [482] STATEMENT:  INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2) RETURNING "public"."AlunoDisciplina"."id"
2023-07-05 23:15:50.811 UTC [482] LOG:  statement: ROLLBACK
2023-07-05 23:15:53.208 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:53.212 UTC [480] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:15:53.231 UTC [480] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:15:53.368 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:53.370 UTC [483] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:15:53.391 UTC [483] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:15:53.395 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:53.398 UTC [483] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:15:53.455 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:53.455 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:53.474 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.476 UTC [483] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.489 UTC [480] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:53.489 UTC [480] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 23:15:53.512 UTC [483] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:53.512 UTC [483] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:15:53.541 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:53.570 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:53.583 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.619 UTC [483] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.627 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:53.635 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:53.644 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.648 UTC [483] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.816 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:53.819 UTC [484] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.864 UTC [484] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:53.864 UTC [484] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:15:53.867 UTC [486] LOG:  statement: select version()
2023-07-05 23:15:53.871 UTC [486] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.886 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:53.887 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:53.893 UTC [483] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.895 UTC [484] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.901 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:53.904 UTC [484] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:53.938 UTC [485] LOG:  statement: select version()
2023-07-05 23:15:53.940 UTC [485] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.686 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:54.686 UTC [485] LOG:  statement: select version()
2023-07-05 23:15:54.690 UTC [484] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:15:54.692 UTC [485] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:15:54.709 UTC [484] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:15:54.714 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:54.715 UTC [485] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:15:54.718 UTC [484] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:15:54.783 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:54.783 UTC [486] LOG:  statement: select version()
2023-07-05 23:15:54.783 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:54.804 UTC [483] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.807 UTC [484] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.808 UTC [486] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.823 UTC [484] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:54.823 UTC [484] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:15:54.826 UTC [483] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:54.826 UTC [483] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 23:15:54.862 UTC [486] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:54.862 UTC [486] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:15:54.875 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:54.875 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:54.902 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:54.903 UTC [486] LOG:  statement: select version()
2023-07-05 23:15:54.914 UTC [485] LOG:  statement: select version()
2023-07-05 23:15:54.926 UTC [486] LOG:  statement: select version()
2023-07-05 23:15:54.927 UTC [485] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.929 UTC [484] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.930 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.932 UTC [483] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.933 UTC [486] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.934 UTC [485] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.950 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:54.954 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:54.977 UTC [484] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:54.978 UTC [486] LOG:  statement: select version()
2023-07-05 23:15:54.992 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:55.033 UTC [486] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.534 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:56.534 UTC [486] LOG:  statement: select version()
2023-07-05 23:15:56.538 UTC [486] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:15:56.539 UTC [484] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:15:56.551 UTC [484] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:15:56.556 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:56.558 UTC [486] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:15:56.562 UTC [484] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:15:56.635 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:56.635 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:56.635 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:56.653 UTC [484] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.655 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.658 UTC [483] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.674 UTC [484] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:56.674 UTC [484] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:15:56.677 UTC [480] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:56.677 UTC [480] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 23:15:56.681 UTC [483] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:15:56.681 UTC [483] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:15:56.707 UTC [485] LOG:  statement: select version()
2023-07-05 23:15:56.707 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:56.736 UTC [484] LOG:  statement: select version()
2023-07-05 23:15:56.736 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:56.756 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:56.757 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:56.760 UTC [485] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.761 UTC [486] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.773 UTC [484] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.774 UTC [486] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.778 UTC [483] LOG:  statement: select version()
2023-07-05 23:15:56.779 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.781 UTC [485] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.809 UTC [486] LOG:  statement: select version()
2023-07-05 23:15:56.820 UTC [483] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.823 UTC [480] LOG:  statement: select version()
2023-07-05 23:15:56.828 UTC [486] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:15:56.841 UTC [480] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:16:34.596 UTC [28] LOG:  checkpoint starting: time
2023-07-05 23:16:35.172 UTC [28] LOG:  checkpoint complete: wrote 6 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.522 s, sync=0.009 s, total=0.576 s; sync files=6, longest=0.004 s, average=0.002 s; distance=5 kB, estimate=8 kB
2023-07-05 23:22:43.581 UTC [501] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:22:43.581 UTC [501] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:22:43.588 UTC [501] LOG:  statement: BEGIN
2023-07-05 23:22:43.601 UTC [501] LOG:  execute s1: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND 1=0) OFFSET $2
2023-07-05 23:22:43.601 UTC [501] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:22:43.605 UTC [501] LOG:  execute s2: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND 1=0)
2023-07-05 23:22:43.605 UTC [501] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e'
2023-07-05 23:22:43.615 UTC [501] LOG:  execute s3: INSERT INTO "public"."AlunoDisciplina" ("id_disciplina","id_aluno") VALUES ($1,$2), ($3,$4)
2023-07-05 23:22:43.615 UTC [501] DETAIL:  parameters: $1 = '2', $2 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $3 = '4', $4 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e'
2023-07-05 23:22:43.618 UTC [501] ERROR:  insert or update on table "AlunoDisciplina" violates foreign key constraint "AlunoDisciplina_id_aluno_fkey"
2023-07-05 23:22:43.618 UTC [501] DETAIL:  Key (id_aluno)=(5e1c0ff2-829c-415b-9c75-caceff0b2a9e) is not present in table "Aluno".
2023-07-05 23:22:43.618 UTC [501] STATEMENT:  INSERT INTO "public"."AlunoDisciplina" ("id_disciplina","id_aluno") VALUES ($1,$2), ($3,$4)
2023-07-05 23:22:43.649 UTC [501] LOG:  statement: ROLLBACK
2023-07-05 23:24:04.177 UTC [504] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:24:04.177 UTC [504] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:24:04.187 UTC [504] LOG:  statement: BEGIN
2023-07-05 23:24:04.192 UTC [504] LOG:  execute s1: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND 1=0) OFFSET $2
2023-07-05 23:24:04.192 UTC [504] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:24:04.196 UTC [504] LOG:  execute s2: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND 1=0)
2023-07-05 23:24:04.196 UTC [504] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e'
2023-07-05 23:24:04.197 UTC [504] LOG:  statement: COMMIT
2023-07-05 23:24:04.206 UTC [504] LOG:  statement: BEGIN
2023-07-05 23:24:04.209 UTC [504] LOG:  execute s3: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2), ($3,$4)
2023-07-05 23:24:04.209 UTC [504] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '2', $3 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $4 = '4'
2023-07-05 23:24:04.214 UTC [504] ERROR:  insert or update on table "AlunoDisciplina" violates foreign key constraint "AlunoDisciplina_id_aluno_fkey"
2023-07-05 23:24:04.214 UTC [504] DETAIL:  Key (id_aluno)=(5e1c0ff2-829c-415b-9c75-caceff0b2a9e) is not present in table "Aluno".
2023-07-05 23:24:04.214 UTC [504] STATEMENT:  INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2), ($3,$4)
2023-07-05 23:24:04.215 UTC [504] LOG:  statement: ROLLBACK
2023-07-05 23:24:09.480 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:09.483 UTC [505] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:24:09.514 UTC [505] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:24:09.539 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:09.541 UTC [506] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:24:09.569 UTC [506] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:24:09.575 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:09.578 UTC [506] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:24:09.647 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:09.677 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:09.728 UTC [506] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:09.728 UTC [506] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:24:09.886 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:09.886 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:09.897 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:09.900 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:09.904 UTC [505] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:09.904 UTC [508] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:09.910 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:09.923 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:09.963 UTC [508] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:09.963 UTC [508] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:24:09.973 UTC [507] LOG:  statement: select version()
2023-07-05 23:24:09.989 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:09.989 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:09.992 UTC [507] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:09.993 UTC [508] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:09.997 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:10.001 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:10.007 UTC [508] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:10.031 UTC [507] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:10.031 UTC [507] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 23:24:10.054 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:10.054 UTC [507] LOG:  statement: select version()
2023-07-05 23:24:10.058 UTC [507] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:10.058 UTC [508] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:10.063 UTC [507] LOG:  statement: select version()
2023-07-05 23:24:10.066 UTC [507] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:11.661 UTC [507] LOG:  statement: select version()
2023-07-05 23:24:11.663 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:11.665 UTC [507] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:24:11.667 UTC [508] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:24:11.678 UTC [507] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:24:11.681 UTC [508] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:24:11.688 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:11.691 UTC [508] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:24:11.755 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:11.755 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:11.755 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:11.780 UTC [508] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:11.782 UTC [505] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:11.786 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:11.802 UTC [508] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:11.802 UTC [508] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:24:11.825 UTC [506] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:11.825 UTC [506] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 23:24:11.843 UTC [505] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:11.843 UTC [505] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:24:11.860 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:11.892 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:11.893 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:11.907 UTC [507] LOG:  statement: select version()
2023-07-05 23:24:11.925 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:11.927 UTC [507] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:11.932 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:11.932 UTC [508] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:11.935 UTC [505] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:11.937 UTC [507] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:11.960 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:11.969 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:11.985 UTC [507] LOG:  statement: select version()
2023-07-05 23:24:11.991 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:11.996 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:11.998 UTC [507] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:11.999 UTC [505] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:24:12.002 UTC [508] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:24:12.006 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.070 UTC [505] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.071 UTC [507] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:24:12.137 UTC [508] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:24:12.157 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:12.160 UTC [508] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:24:12.237 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:12.237 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:12.238 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:12.262 UTC [509] LOG:  statement: select version()
2023-07-05 23:24:12.272 UTC [508] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.272 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.275 UTC [505] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.275 UTC [509] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.285 UTC [508] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:12.285 UTC [508] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:24:12.297 UTC [506] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:12.297 UTC [506] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:24:12.302 UTC [505] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:12.302 UTC [505] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 23:24:12.325 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:12.325 UTC [507] LOG:  statement: select version()
2023-07-05 23:24:12.335 UTC [509] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:12.335 UTC [509] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:24:12.358 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:12.366 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:12.391 UTC [507] LOG:  statement: select version()
2023-07-05 23:24:12.392 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:12.393 UTC [509] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.403 UTC [505] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.405 UTC [508] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.407 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.409 UTC [507] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.410 UTC [509] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.421 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:12.424 UTC [509] LOG:  statement: select version()
2023-07-05 23:24:12.447 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:12.456 UTC [505] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.458 UTC [509] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.461 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.836 UTC [509] LOG:  statement: select version()
2023-07-05 23:24:12.837 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:12.839 UTC [509] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:24:12.840 UTC [506] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:24:12.854 UTC [509] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:24:12.855 UTC [506] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:24:12.862 UTC [509] LOG:  statement: select version()
2023-07-05 23:24:12.864 UTC [509] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:24:12.935 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:12.935 UTC [507] LOG:  statement: select version()
2023-07-05 23:24:12.935 UTC [509] LOG:  statement: select version()
2023-07-05 23:24:12.959 UTC [507] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.961 UTC [505] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.965 UTC [509] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:12.979 UTC [507] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:12.979 UTC [507] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:24:12.994 UTC [505] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:12.994 UTC [505] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 23:24:12.998 UTC [509] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:24:12.998 UTC [509] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:24:13.017 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:13.017 UTC [507] LOG:  statement: select version()
2023-07-05 23:24:13.054 UTC [509] LOG:  statement: select version()
2023-07-05 23:24:13.055 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:13.082 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:13.085 UTC [508] LOG:  statement: select version()
2023-07-05 23:24:13.087 UTC [507] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:13.089 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:13.102 UTC [509] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:13.103 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:13.110 UTC [505] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:13.111 UTC [508] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:13.142 UTC [506] LOG:  statement: select version()
2023-07-05 23:24:13.147 UTC [509] LOG:  statement: select version()
2023-07-05 23:24:13.152 UTC [505] LOG:  statement: select version()
2023-07-05 23:24:13.163 UTC [506] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:13.167 UTC [509] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:13.168 UTC [505] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:24:44.572 UTC [512] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:24:44.572 UTC [512] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:24:44.582 UTC [512] LOG:  statement: BEGIN
2023-07-05 23:24:44.586 UTC [512] LOG:  execute s1: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND 1=0) OFFSET $2
2023-07-05 23:24:44.586 UTC [512] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e', $2 = '0'
2023-07-05 23:24:44.590 UTC [512] LOG:  execute s2: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND 1=0)
2023-07-05 23:24:44.590 UTC [512] DETAIL:  parameters: $1 = '5e1c0ff2-829c-415b-9c75-caceff0b2a9e'
2023-07-05 23:24:44.592 UTC [512] LOG:  statement: COMMIT
2023-07-05 23:25:04.316 UTC [513] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:25:04.316 UTC [513] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 23:25:28.074 UTC [515] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:25:28.074 UTC [515] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-05 23:25:28.086 UTC [515] LOG:  statement: BEGIN
2023-07-05 23:25:28.090 UTC [515] LOG:  execute s1: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2)) OFFSET $3
2023-07-05 23:25:28.090 UTC [515] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '1', $3 = '0'
2023-07-05 23:25:28.093 UTC [515] LOG:  execute s2: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2))
2023-07-05 23:25:28.093 UTC [515] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '1'
2023-07-05 23:25:28.098 UTC [515] LOG:  execute s3: DELETE FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id" IN ($1) AND ("public"."AlunoDisciplina"."id_aluno" = $2 AND "public"."AlunoDisciplina"."id_disciplina" IN ($3)))
2023-07-05 23:25:28.098 UTC [515] DETAIL:  parameters: $1 = '20', $2 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $3 = '1'
2023-07-05 23:25:28.102 UTC [515] LOG:  statement: COMMIT
2023-07-05 23:25:28.120 UTC [515] LOG:  statement: BEGIN
2023-07-05 23:25:28.123 UTC [515] LOG:  execute s4: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2), ($3,$4)
2023-07-05 23:25:28.123 UTC [515] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '2', $3 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $4 = '4'
2023-07-05 23:25:28.134 UTC [515] LOG:  statement: COMMIT
2023-07-05 23:25:33.547 UTC [517] LOG:  statement: select version()
2023-07-05 23:25:33.550 UTC [517] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:25:33.585 UTC [517] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:25:33.590 UTC [517] LOG:  statement: select version()
2023-07-05 23:25:33.593 UTC [517] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:25:33.666 UTC [517] LOG:  statement: select version()
2023-07-05 23:25:33.684 UTC [516] LOG:  statement: select version()
2023-07-05 23:25:33.692 UTC [517] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:33.697 UTC [516] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:25:33.738 UTC [516] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:25:33.754 UTC [517] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:25:33.754 UTC [517] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:25:33.945 UTC [517] LOG:  statement: select version()
2023-07-05 23:25:33.948 UTC [518] LOG:  statement: select version()
2023-07-05 23:25:33.963 UTC [517] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:33.965 UTC [518] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:33.971 UTC [517] LOG:  statement: select version()
2023-07-05 23:25:33.976 UTC [517] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:34.016 UTC [518] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:25:34.016 UTC [518] DETAIL:  parameters: $1 = 'public', $2 = 'Aluno'
2023-07-05 23:25:34.114 UTC [518] LOG:  statement: select version()
2023-07-05 23:25:34.115 UTC [517] LOG:  statement: select version()
2023-07-05 23:25:34.117 UTC [519] LOG:  statement: select version()
2023-07-05 23:25:34.125 UTC [517] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:34.128 UTC [519] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:34.132 UTC [518] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:34.137 UTC [520] LOG:  statement: select version()
2023-07-05 23:25:34.142 UTC [518] LOG:  statement: select version()
2023-07-05 23:25:34.148 UTC [520] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:34.156 UTC [518] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Aluno"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:34.186 UTC [519] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:25:34.186 UTC [519] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-05 23:25:34.221 UTC [518] LOG:  statement: select version()
2023-07-05 23:25:34.221 UTC [519] LOG:  statement: select version()
2023-07-05 23:25:34.224 UTC [518] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:34.225 UTC [519] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:34.232 UTC [519] LOG:  statement: select version()
2023-07-05 23:25:34.235 UTC [519] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:38.707 UTC [519] LOG:  statement: select version()
2023-07-05 23:25:38.711 UTC [519] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:38.743 UTC [519] LOG:  statement: select version()
2023-07-05 23:25:38.750 UTC [519] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:42.066 UTC [519] LOG:  statement: select version()
2023-07-05 23:25:42.067 UTC [518] LOG:  statement: select version()
2023-07-05 23:25:42.070 UTC [519] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:25:42.072 UTC [518] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:25:42.087 UTC [518] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:25:42.087 UTC [519] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:25:42.094 UTC [518] LOG:  statement: select version()
2023-07-05 23:25:42.097 UTC [518] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:25:42.157 UTC [518] LOG:  statement: select version()
2023-07-05 23:25:42.174 UTC [518] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:42.186 UTC [518] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:25:42.186 UTC [518] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:25:42.220 UTC [520] LOG:  statement: select version()
2023-07-05 23:25:42.220 UTC [518] LOG:  statement: select version()
2023-07-05 23:25:42.227 UTC [518] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:42.229 UTC [520] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:42.244 UTC [518] LOG:  statement: select version()
2023-07-05 23:25:42.252 UTC [518] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:25:57.663 UTC [515] LOG:  statement: SELECT 1
2023-07-05 23:25:57.666 UTC [515] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:25:57.666 UTC [515] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-05 23:25:57.672 UTC [515] LOG:  statement: BEGIN
2023-07-05 23:25:57.677 UTC [515] LOG:  execute s5: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2,$3)) OFFSET $4
2023-07-05 23:25:57.677 UTC [515] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '2', $3 = '4', $4 = '0'
2023-07-05 23:25:57.682 UTC [515] LOG:  execute s6: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2,$3))
2023-07-05 23:25:57.682 UTC [515] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '2', $3 = '4'
2023-07-05 23:25:57.686 UTC [515] LOG:  execute s7: DELETE FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id" IN ($1,$2) AND ("public"."AlunoDisciplina"."id_aluno" = $3 AND "public"."AlunoDisciplina"."id_disciplina" IN ($4,$5)))
2023-07-05 23:25:57.686 UTC [515] DETAIL:  parameters: $1 = '26', $2 = '27', $3 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $4 = '2', $5 = '4'
2023-07-05 23:25:57.688 UTC [515] LOG:  statement: COMMIT
2023-07-05 23:25:57.695 UTC [515] LOG:  statement: BEGIN
2023-07-05 23:25:57.697 UTC [515] LOG:  execute s4: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2), ($3,$4)
2023-07-05 23:25:57.697 UTC [515] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '1', $3 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $4 = '3'
2023-07-05 23:25:57.700 UTC [515] LOG:  statement: COMMIT
2023-07-05 23:26:01.472 UTC [518] LOG:  statement: select version()
2023-07-05 23:26:01.474 UTC [520] LOG:  statement: select version()
2023-07-05 23:26:01.478 UTC [518] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:26:01.478 UTC [520] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:26:01.493 UTC [518] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:26:01.505 UTC [520] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:26:01.510 UTC [520] LOG:  statement: select version()
2023-07-05 23:26:01.512 UTC [520] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:26:01.570 UTC [520] LOG:  statement: select version()
2023-07-05 23:26:01.589 UTC [520] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:26:01.616 UTC [520] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:26:01.616 UTC [520] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:26:01.672 UTC [519] LOG:  statement: select version()
2023-07-05 23:26:01.672 UTC [520] LOG:  statement: select version()
2023-07-05 23:26:01.699 UTC [519] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:26:01.703 UTC [520] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:26:01.710 UTC [520] LOG:  statement: select version()
2023-07-05 23:26:01.726 UTC [520] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:26:34.379 UTC [28] LOG:  checkpoint starting: time
2023-07-05 23:26:34.950 UTC [28] LOG:  checkpoint complete: wrote 6 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.520 s, sync=0.009 s, total=0.572 s; sync files=6, longest=0.004 s, average=0.002 s; distance=7 kB, estimate=8 kB
2023-07-05 23:32:29.283 UTC [535] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:32:29.283 UTC [535] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-05 23:32:29.295 UTC [535] LOG:  statement: BEGIN
2023-07-05 23:32:29.301 UTC [535] LOG:  execute s1: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2,$3)) OFFSET $4
2023-07-05 23:32:29.301 UTC [535] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '1', $3 = '3', $4 = '0'
2023-07-05 23:32:29.305 UTC [535] LOG:  execute s2: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2,$3))
2023-07-05 23:32:29.305 UTC [535] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '1', $3 = '3'
2023-07-05 23:32:29.309 UTC [535] LOG:  execute s3: DELETE FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id" IN ($1,$2) AND ("public"."AlunoDisciplina"."id_aluno" = $3 AND "public"."AlunoDisciplina"."id_disciplina" IN ($4,$5)))
2023-07-05 23:32:29.309 UTC [535] DETAIL:  parameters: $1 = '28', $2 = '29', $3 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $4 = '1', $5 = '3'
2023-07-05 23:32:29.315 UTC [535] LOG:  execute s4: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2), ($3,$4)
2023-07-05 23:32:29.315 UTC [535] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '2', $3 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $4 = '4'
2023-07-05 23:32:29.324 UTC [535] LOG:  statement: COMMIT
2023-07-05 23:32:32.430 UTC [537] LOG:  statement: select version()
2023-07-05 23:32:32.435 UTC [537] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-05 23:32:32.465 UTC [537] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-05 23:32:32.470 UTC [537] LOG:  statement: select version()
2023-07-05 23:32:32.472 UTC [537] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-05 23:32:32.538 UTC [537] LOG:  statement: select version()
2023-07-05 23:32:32.551 UTC [536] LOG:  statement: select version()
2023-07-05 23:32:32.554 UTC [537] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:32:32.558 UTC [536] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-05 23:32:32.583 UTC [536] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-05 23:32:32.595 UTC [537] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-05 23:32:32.595 UTC [537] DETAIL:  parameters: $1 = 'public', $2 = 'AlunoDisciplina'
2023-07-05 23:32:32.661 UTC [537] LOG:  statement: select version()
2023-07-05 23:32:32.672 UTC [537] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:32:32.682 UTC [537] LOG:  statement: select version()
2023-07-05 23:32:32.689 UTC [537] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:32:32.852 UTC [538] LOG:  statement: select version()
2023-07-05 23:32:32.855 UTC [538] LOG:  statement: 
	    SELECT * 
	    FROM "public"."AlunoDisciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-05 23:34:00.477 UTC [542] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:34:00.477 UTC [542] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-05 23:34:00.493 UTC [542] LOG:  statement: BEGIN
2023-07-05 23:34:00.498 UTC [542] LOG:  execute s1: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2,$3)) OFFSET $4
2023-07-05 23:34:00.498 UTC [542] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '2', $3 = '4', $4 = '0'
2023-07-05 23:34:00.500 UTC [542] LOG:  execute s2: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2,$3))
2023-07-05 23:34:00.500 UTC [542] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '2', $3 = '4'
2023-07-05 23:34:00.504 UTC [542] LOG:  execute s3: DELETE FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id" IN ($1,$2) AND ("public"."AlunoDisciplina"."id_aluno" = $3 AND "public"."AlunoDisciplina"."id_disciplina" IN ($4,$5)))
2023-07-05 23:34:00.504 UTC [542] DETAIL:  parameters: $1 = '30', $2 = '31', $3 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $4 = '2', $5 = '4'
2023-07-05 23:34:00.511 UTC [542] LOG:  execute s4: INSERT INTO "public"."AlunoDisciplina" ("id_disciplina","id_aluno") VALUES ($1,$2), ($3,$4)
2023-07-05 23:34:00.511 UTC [542] DETAIL:  parameters: $1 = '1', $2 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $3 = '3', $4 = '49fa7012-7adb-41d9-a6b0-a951e3cab351'
2023-07-05 23:34:00.518 UTC [542] LOG:  statement: COMMIT
2023-07-05 23:35:24.786 UTC [546] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:35:24.786 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-05 23:35:24.798 UTC [546] LOG:  statement: BEGIN
2023-07-05 23:35:24.804 UTC [546] LOG:  execute s1: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2,$3)) OFFSET $4
2023-07-05 23:35:24.804 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '1', $3 = '3', $4 = '0'
2023-07-05 23:35:24.808 UTC [546] LOG:  execute s2: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2,$3))
2023-07-05 23:35:24.808 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '1', $3 = '3'
2023-07-05 23:35:24.811 UTC [546] LOG:  execute s3: DELETE FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id" IN ($1,$2) AND ("public"."AlunoDisciplina"."id_aluno" = $3 AND "public"."AlunoDisciplina"."id_disciplina" IN ($4,$5)))
2023-07-05 23:35:24.811 UTC [546] DETAIL:  parameters: $1 = '32', $2 = '33', $3 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $4 = '1', $5 = '3'
2023-07-05 23:35:24.818 UTC [546] LOG:  execute s4: INSERT INTO "public"."AlunoDisciplina" ("id_disciplina","id_aluno") VALUES ($1,$2), ($3,$4)
2023-07-05 23:35:24.818 UTC [546] DETAIL:  parameters: $1 = '2', $2 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $3 = '4', $4 = '49fa7012-7adb-41d9-a6b0-a951e3cab351'
2023-07-05 23:35:24.828 UTC [546] LOG:  statement: COMMIT
2023-07-05 23:35:26.718 UTC [546] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:35:26.718 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-05 23:35:26.723 UTC [546] LOG:  statement: BEGIN
2023-07-05 23:35:26.726 UTC [546] LOG:  execute s5: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND 1=0) OFFSET $2
2023-07-05 23:35:26.726 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-05 23:35:26.729 UTC [546] LOG:  execute s6: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND 1=0)
2023-07-05 23:35:26.729 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351'
2023-07-05 23:35:26.731 UTC [546] LOG:  statement: COMMIT
2023-07-05 23:35:28.822 UTC [546] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:35:28.822 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-05 23:35:28.829 UTC [546] LOG:  statement: BEGIN
2023-07-05 23:35:28.831 UTC [546] LOG:  execute s5: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND 1=0) OFFSET $2
2023-07-05 23:35:28.831 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-05 23:35:28.834 UTC [546] LOG:  execute s6: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND 1=0)
2023-07-05 23:35:28.834 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351'
2023-07-05 23:35:28.836 UTC [546] LOG:  statement: COMMIT
2023-07-05 23:35:46.142 UTC [546] LOG:  statement: SELECT 1
2023-07-05 23:35:46.145 UTC [546] LOG:  execute s0: SELECT "public"."AlunoDisciplina"."id", "public"."AlunoDisciplina"."id_disciplina" FROM "public"."AlunoDisciplina" WHERE "public"."AlunoDisciplina"."id_aluno" = $1 OFFSET $2
2023-07-05 23:35:46.145 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '0'
2023-07-05 23:35:46.155 UTC [546] LOG:  statement: BEGIN
2023-07-05 23:35:46.158 UTC [546] LOG:  execute s1: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2,$3)) OFFSET $4
2023-07-05 23:35:46.158 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '2', $3 = '4', $4 = '0'
2023-07-05 23:35:46.160 UTC [546] LOG:  execute s2: SELECT "public"."AlunoDisciplina"."id" FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id_aluno" = $1 AND "public"."AlunoDisciplina"."id_disciplina" IN ($2,$3))
2023-07-05 23:35:46.160 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '2', $3 = '4'
2023-07-05 23:35:46.162 UTC [546] LOG:  execute s3: DELETE FROM "public"."AlunoDisciplina" WHERE ("public"."AlunoDisciplina"."id" IN ($1,$2) AND ("public"."AlunoDisciplina"."id_aluno" = $3 AND "public"."AlunoDisciplina"."id_disciplina" IN ($4,$5)))
2023-07-05 23:35:46.162 UTC [546] DETAIL:  parameters: $1 = '34', $2 = '35', $3 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $4 = '2', $5 = '4'
2023-07-05 23:35:46.167 UTC [546] LOG:  execute s7: INSERT INTO "public"."AlunoDisciplina" ("id_aluno","id_disciplina") VALUES ($1,$2), ($3,$4)
2023-07-05 23:35:46.167 UTC [546] DETAIL:  parameters: $1 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $2 = '1', $3 = '49fa7012-7adb-41d9-a6b0-a951e3cab351', $4 = '3'
2023-07-05 23:35:46.170 UTC [546] LOG:  statement: COMMIT
2023-07-05 23:36:35.155 UTC [28] LOG:  checkpoint starting: time
2023-07-05 23:36:35.733 UTC [28] LOG:  checkpoint complete: wrote 6 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.525 s, sync=0.009 s, total=0.578 s; sync files=6, longest=0.004 s, average=0.002 s; distance=8 kB, estimate=8 kB
2023-07-05 23:38:57.534 UTC [1] LOG:  received fast shutdown request
2023-07-05 23:38:57.547 UTC [1] LOG:  aborting any active transactions
2023-07-05 23:38:57.551 UTC [1] LOG:  background worker "logical replication launcher" (PID 33) exited with exit code 1
2023-07-05 23:38:57.556 UTC [28] LOG:  shutting down
2023-07-05 23:38:57.568 UTC [28] LOG:  checkpoint starting: shutdown immediate
2023-07-05 23:38:57.653 UTC [28] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.011 s, sync=0.001 s, total=0.097 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=7 kB
2023-07-05 23:38:57.693 UTC [1] LOG:  database system is shut down
