2023-08-17 14:12:54.295 UTC [1] LOG:  starting PostgreSQL 15.3 (Debian 15.3-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
2023-08-17 14:12:54.296 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2023-08-17 14:12:54.296 UTC [1] LOG:  listening on IPv6 address "::", port 5432
2023-08-17 14:12:54.314 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2023-08-17 14:12:54.390 UTC [30] LOG:  database system was interrupted; last known up at 2023-08-16 23:10:09 UTC
2023-08-17 14:13:04.406 UTC [30] LOG:  syncing data directory (pre-fsync), elapsed time: 10.00 s, current path: ./base/4/3085
2023-08-17 14:13:15.522 UTC [30] LOG:  database system was not properly shut down; automatic recovery in progress
2023-08-17 14:13:15.638 UTC [30] LOG:  redo starts at 0/89202C8
2023-08-17 14:13:15.639 UTC [30] LOG:  invalid record length at 0/89203B0: wanted 24, got 0
2023-08-17 14:13:15.639 UTC [30] LOG:  redo done at 0/8920378 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
2023-08-17 14:13:15.835 UTC [28] LOG:  checkpoint starting: end-of-recovery immediate wait
2023-08-17 14:13:16.037 UTC [28] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.075 s, sync=0.026 s, total=0.211 s; sync files=3, longest=0.012 s, average=0.009 s; distance=0 kB, estimate=0 kB
2023-08-17 14:13:16.141 UTC [1] LOG:  database system is ready to accept connections
2023-08-17 14:27:23.709 UTC [34] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:27:23.731 UTC [34] LOG:  execute s0: SELECT version()
2023-08-17 14:27:23.772 UTC [34] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:27:23.772 UTC [34] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:27:23.986 UTC [35] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:27:23.989 UTC [35] LOG:  execute s0: SELECT version()
2023-08-17 14:27:23.996 UTC [35] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:27:23.996 UTC [35] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:27:24.022 UTC [35] LOG:  execute s2: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-08-17 14:27:24.145 UTC [35] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_82c7a4c9-7bb3-4067-b9d1-9f43780f4135"
2023-08-17 14:27:28.692 UTC [36] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:27:28.696 UTC [36] LOG:  execute s3: SELECT version()
2023-08-17 14:27:28.708 UTC [36] LOG:  execute s4: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:27:28.708 UTC [36] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:27:28.710 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-08-17 14:27:29.040 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:29.581 UTC [36] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:29.885 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-08-17 14:27:29.944 UTC [36] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-08-17 14:27:29.964 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:30.025 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-08-17 14:27:30.063 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:30.132 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:30.205 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:30.275 UTC [36] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:30.356 UTC [36] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-08-17 14:27:30.362 UTC [36] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:30.373 UTC [36] LOG:  statement: /*
	  Warnings:
	
	  - Added the required column `carga_horaria` to the `Disciplina` table without a default value. This is not possible if the table is not empty.
	
	*/
	-- AlterTable
	ALTER TABLE "Disciplina" ADD COLUMN     "carga_horaria" INTEGER NOT NULL;
	
2023-08-17 14:27:30.378 UTC [36] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `ProfessorDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey";
	
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_professor_fkey";
	
	-- DropTable
	DROP TABLE "ProfessorDisciplina";
	
	-- CreateTable
	CREATE TABLE "ProfessorCursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_cursoDisciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorCursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_cursoDisciplina_fkey" FOREIGN KEY ("id_cursoDisciplina") REFERENCES "CursoDisciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:30.469 UTC [36] LOG:  execute s5: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-08-17 14:27:30.469 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:30.486 UTC [36] LOG:  execute s6: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-08-17 14:27:30.486 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:30.498 UTC [36] LOG:  execute s7: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-08-17 14:27:30.498 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:30.507 UTC [36] LOG:  execute s8: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-08-17 14:27:30.507 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:30.513 UTC [36] LOG:  execute s9: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-08-17 14:27:30.513 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:30.537 UTC [36] LOG:  execute s10: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-08-17 14:27:30.537 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:30.553 UTC [36] LOG:  execute s11: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-08-17 14:27:30.553 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:30.570 UTC [36] LOG:  execute s12: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-08-17 14:27:30.570 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:30.585 UTC [36] LOG:  execute s13: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-08-17 14:27:30.585 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:30.639 UTC [36] LOG:  execute s14: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-08-17 14:27:30.645 UTC [36] LOG:  execute s15: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-08-17 14:27:30.645 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:30.647 UTC [35] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_82c7a4c9-7bb3-4067-b9d1-9f43780f4135"
2023-08-17 14:27:30.656 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-08-17 14:27:31.098 UTC [28] LOG:  checkpoint complete: wrote 5 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.279 s, sync=0.076 s, total=0.443 s; sync files=5, longest=0.021 s, average=0.016 s; distance=4565 kB, estimate=4565 kB
2023-08-17 14:27:33.372 UTC [35] LOG:  execute s16: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-08-17 14:27:33.372 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:33.394 UTC [35] LOG:  execute s17: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-08-17 14:27:33.394 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:33.412 UTC [35] LOG:  execute s18: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-08-17 14:27:33.412 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:33.425 UTC [35] LOG:  execute s19: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-08-17 14:27:33.425 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:33.440 UTC [35] LOG:  execute s20: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-08-17 14:27:33.440 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:33.502 UTC [35] LOG:  execute s21: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-08-17 14:27:33.502 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:33.528 UTC [35] LOG:  execute s22: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-08-17 14:27:33.528 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:33.568 UTC [35] LOG:  execute s23: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-08-17 14:27:33.568 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:33.583 UTC [35] LOG:  execute s24: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-08-17 14:27:33.583 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:33.621 UTC [35] LOG:  execute s25: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-08-17 14:27:33.629 UTC [35] LOG:  execute s26: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-08-17 14:27:33.629 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:33.634 UTC [35] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_5c17a1b5-625b-4440-8a5d-e5ad20cc7590"
2023-08-17 14:27:37.224 UTC [38] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:27:37.228 UTC [38] LOG:  execute s27: SELECT version()
2023-08-17 14:27:37.237 UTC [38] LOG:  execute s28: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:27:37.237 UTC [38] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:27:37.239 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-08-17 14:27:37.306 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:37.366 UTC [38] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:37.443 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-08-17 14:27:37.494 UTC [38] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-08-17 14:27:37.512 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:37.566 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-08-17 14:27:37.602 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:37.652 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:37.738 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:37.801 UTC [38] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:37.876 UTC [38] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-08-17 14:27:37.880 UTC [38] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:37.889 UTC [38] LOG:  statement: /*
	  Warnings:
	
	  - Added the required column `carga_horaria` to the `Disciplina` table without a default value. This is not possible if the table is not empty.
	
	*/
	-- AlterTable
	ALTER TABLE "Disciplina" ADD COLUMN     "carga_horaria" INTEGER NOT NULL;
	
2023-08-17 14:27:37.894 UTC [38] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `ProfessorDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey";
	
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_professor_fkey";
	
	-- DropTable
	DROP TABLE "ProfessorDisciplina";
	
	-- CreateTable
	CREATE TABLE "ProfessorCursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_cursoDisciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorCursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_cursoDisciplina_fkey" FOREIGN KEY ("id_cursoDisciplina") REFERENCES "CursoDisciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:37.975 UTC [38] LOG:  execute s29: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-08-17 14:27:37.975 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:37.986 UTC [38] LOG:  execute s30: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-08-17 14:27:37.986 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:37.996 UTC [38] LOG:  execute s31: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-08-17 14:27:37.996 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:38.003 UTC [38] LOG:  execute s32: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-08-17 14:27:38.003 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:38.009 UTC [38] LOG:  execute s33: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-08-17 14:27:38.009 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:38.032 UTC [38] LOG:  execute s34: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-08-17 14:27:38.032 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:38.046 UTC [38] LOG:  execute s35: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-08-17 14:27:38.046 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:38.063 UTC [38] LOG:  execute s36: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-08-17 14:27:38.063 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:38.077 UTC [38] LOG:  execute s37: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-08-17 14:27:38.077 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:38.085 UTC [38] LOG:  execute s38: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-08-17 14:27:38.089 UTC [38] LOG:  execute s39: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-08-17 14:27:38.089 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:38.091 UTC [35] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_5c17a1b5-625b-4440-8a5d-e5ad20cc7590"
2023-08-17 14:27:38.200 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-08-17 14:27:38.357 UTC [28] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 1 recycled; write=0.025 s, sync=0.010 s, total=0.157 s; sync files=8, longest=0.004 s, average=0.002 s; distance=4566 kB, estimate=4566 kB
2023-08-17 14:27:40.540 UTC [35] LOG:  statement: SELECT pg_advisory_lock(72707369)
2023-08-17 14:27:40.553 UTC [35] LOG:  execute s40: 
	                SELECT tbl.relname AS table_name
	                FROM pg_class AS tbl
	                INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	                WHERE tbl.relkind = 'r' AND namespace.nspname = ANY ( $1 )
	            
2023-08-17 14:27:40.553 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:40.559 UTC [35] LOG:  execute s41: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-08-17 14:27:40.565 UTC [35] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_0be34744-53a8-4d87-91e2-8ebe92a6ec69"
2023-08-17 14:27:44.442 UTC [39] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:27:44.446 UTC [39] LOG:  execute s42: SELECT version()
2023-08-17 14:27:44.456 UTC [39] LOG:  execute s43: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:27:44.456 UTC [39] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:27:44.458 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-08-17 14:27:44.541 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:44.611 UTC [39] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:44.700 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-08-17 14:27:44.777 UTC [39] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-08-17 14:27:44.798 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:44.870 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-08-17 14:27:44.909 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:44.966 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:45.037 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:45.108 UTC [39] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:45.176 UTC [39] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-08-17 14:27:45.180 UTC [39] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:45.188 UTC [39] LOG:  statement: /*
	  Warnings:
	
	  - Added the required column `carga_horaria` to the `Disciplina` table without a default value. This is not possible if the table is not empty.
	
	*/
	-- AlterTable
	ALTER TABLE "Disciplina" ADD COLUMN     "carga_horaria" INTEGER NOT NULL;
	
2023-08-17 14:27:45.192 UTC [39] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `ProfessorDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey";
	
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_professor_fkey";
	
	-- DropTable
	DROP TABLE "ProfessorDisciplina";
	
	-- CreateTable
	CREATE TABLE "ProfessorCursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_cursoDisciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorCursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_cursoDisciplina_fkey" FOREIGN KEY ("id_cursoDisciplina") REFERENCES "CursoDisciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:27:45.264 UTC [39] LOG:  execute s44: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-08-17 14:27:45.264 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:45.275 UTC [39] LOG:  execute s45: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-08-17 14:27:45.275 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:45.285 UTC [39] LOG:  execute s46: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-08-17 14:27:45.285 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:45.291 UTC [39] LOG:  execute s47: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-08-17 14:27:45.291 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:45.297 UTC [39] LOG:  execute s48: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-08-17 14:27:45.297 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:45.319 UTC [39] LOG:  execute s49: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-08-17 14:27:45.319 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:45.335 UTC [39] LOG:  execute s50: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-08-17 14:27:45.335 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:45.352 UTC [39] LOG:  execute s51: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-08-17 14:27:45.352 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:45.365 UTC [39] LOG:  execute s52: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-08-17 14:27:45.365 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:45.372 UTC [39] LOG:  execute s53: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-08-17 14:27:45.377 UTC [39] LOG:  execute s54: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-08-17 14:27:45.377 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:27:45.379 UTC [35] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_0be34744-53a8-4d87-91e2-8ebe92a6ec69"
2023-08-17 14:27:45.499 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-08-17 14:27:45.632 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.023 s, sync=0.008 s, total=0.134 s; sync files=4, longest=0.005 s, average=0.002 s; distance=4566 kB, estimate=4566 kB
2023-08-17 14:27:47.949 UTC [35] LOG:  execute s55: SELECT COUNT(*) FROM "AlunoDisciplina"
2023-08-17 14:28:18.894 UTC [35] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_2346e058-c373-4e47-a6f1-83a9cb52ef85"
2023-08-17 14:28:22.375 UTC [40] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:28:22.379 UTC [40] LOG:  execute s56: SELECT version()
2023-08-17 14:28:22.386 UTC [40] LOG:  execute s57: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:28:22.386 UTC [40] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:28:22.389 UTC [40] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-08-17 14:28:22.454 UTC [40] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:28:22.511 UTC [40] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:28:22.594 UTC [40] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-08-17 14:28:22.652 UTC [40] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-08-17 14:28:22.670 UTC [40] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:28:22.725 UTC [40] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-08-17 14:28:22.760 UTC [40] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:28:22.811 UTC [40] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:28:22.873 UTC [40] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:28:22.937 UTC [40] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:28:23.021 UTC [40] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-08-17 14:28:23.026 UTC [40] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:28:23.034 UTC [40] LOG:  statement: /*
	  Warnings:
	
	  - Added the required column `carga_horaria` to the `Disciplina` table without a default value. This is not possible if the table is not empty.
	
	*/
	-- AlterTable
	ALTER TABLE "Disciplina" ADD COLUMN     "carga_horaria" INTEGER NOT NULL;
	
2023-08-17 14:28:23.039 UTC [40] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `ProfessorDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey";
	
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_professor_fkey";
	
	-- DropTable
	DROP TABLE "ProfessorDisciplina";
	
	-- CreateTable
	CREATE TABLE "ProfessorCursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_cursoDisciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorCursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_cursoDisciplina_fkey" FOREIGN KEY ("id_cursoDisciplina") REFERENCES "CursoDisciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:28:23.133 UTC [40] LOG:  execute s58: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-08-17 14:28:23.133 UTC [40] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:23.149 UTC [40] LOG:  execute s59: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-08-17 14:28:23.149 UTC [40] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:23.162 UTC [40] LOG:  execute s60: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-08-17 14:28:23.162 UTC [40] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:23.170 UTC [40] LOG:  execute s61: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-08-17 14:28:23.170 UTC [40] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:23.180 UTC [40] LOG:  execute s62: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-08-17 14:28:23.180 UTC [40] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:23.212 UTC [40] LOG:  execute s63: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-08-17 14:28:23.212 UTC [40] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:23.235 UTC [40] LOG:  execute s64: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-08-17 14:28:23.235 UTC [40] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:23.256 UTC [40] LOG:  execute s65: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-08-17 14:28:23.256 UTC [40] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:23.273 UTC [40] LOG:  execute s66: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-08-17 14:28:23.273 UTC [40] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:23.283 UTC [40] LOG:  execute s67: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-08-17 14:28:23.289 UTC [40] LOG:  execute s68: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-08-17 14:28:23.289 UTC [40] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:23.291 UTC [35] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_2346e058-c373-4e47-a6f1-83a9cb52ef85"
2023-08-17 14:28:23.298 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-08-17 14:28:23.530 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.134 s, sync=0.008 s, total=0.232 s; sync files=4, longest=0.005 s, average=0.002 s; distance=4566 kB, estimate=4566 kB
2023-08-17 14:28:25.682 UTC [35] LOG:  statement: SELECT pg_advisory_lock(72707369)
2023-08-17 14:28:25.695 UTC [35] LOG:  execute s69: 
	                SELECT tbl.relname AS table_name
	                FROM pg_class AS tbl
	                INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	                WHERE tbl.relkind = 'r' AND namespace.nspname = ANY ( $1 )
	            
2023-08-17 14:28:25.695 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:28:25.701 UTC [35] LOG:  execute s70: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-08-17 14:28:25.706 UTC [35] LOG:  execute s71: INSERT INTO "_prisma_migrations" ("id","checksum","started_at","migration_name") VALUES ($1,$2,$3,$4)
2023-08-17 14:28:25.706 UTC [35] DETAIL:  parameters: $1 = '8a345a04-ae10-4929-b56e-2eb7a02e7a79', $2 = '3ddcbc058098bbe7ff017fa9279d771a5d0f60007fdcdb94ad08e6e20c4d3972', $3 = '2023-08-17 14:28:25.703395+00', $4 = '20230817142825_delete_table_aluno_disciplina'
2023-08-17 14:28:25.712 UTC [35] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `AlunoDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "AlunoDisciplina" DROP CONSTRAINT "AlunoDisciplina_id_aluno_fkey";
	
	-- DropForeignKey
	ALTER TABLE "AlunoDisciplina" DROP CONSTRAINT "AlunoDisciplina_id_disciplina_fkey";
	
	-- DropTable
	DROP TABLE "AlunoDisciplina";
	
2023-08-17 14:28:25.763 UTC [35] LOG:  execute s72: UPDATE "_prisma_migrations" SET "applied_steps_count" = ("applied_steps_count" + $1) WHERE "id" = $2
2023-08-17 14:28:25.763 UTC [35] DETAIL:  parameters: $1 = '1', $2 = '8a345a04-ae10-4929-b56e-2eb7a02e7a79'
2023-08-17 14:28:25.773 UTC [35] LOG:  execute s73: UPDATE "_prisma_migrations" SET "finished_at" = $1 WHERE "id" = $2
2023-08-17 14:28:25.773 UTC [35] DETAIL:  parameters: $1 = '2023-08-17 14:28:25.771081+00', $2 = '8a345a04-ae10-4929-b56e-2eb7a02e7a79'
2023-08-17 14:33:23.615 UTC [28] LOG:  checkpoint starting: time
2023-08-17 14:33:25.356 UTC [28] LOG:  checkpoint complete: wrote 17 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.660 s, sync=0.018 s, total=1.741 s; sync files=14, longest=0.004 s, average=0.002 s; distance=93 kB, estimate=4119 kB
2023-08-17 14:36:46.628 UTC [49] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:36:46.632 UTC [49] LOG:  execute s0: SELECT version()
2023-08-17 14:36:46.640 UTC [49] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:36:46.640 UTC [49] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:36:46.841 UTC [50] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:36:46.844 UTC [50] LOG:  execute s0: SELECT version()
2023-08-17 14:36:46.851 UTC [50] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:36:46.851 UTC [50] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:36:46.857 UTC [50] LOG:  execute s2: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-08-17 14:36:46.861 UTC [50] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_aba8a591-13b2-4ab1-b89a-a618edc3ee0b"
2023-08-17 14:36:49.945 UTC [51] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:36:49.949 UTC [51] LOG:  execute s3: SELECT version()
2023-08-17 14:36:49.957 UTC [51] LOG:  execute s4: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:36:49.957 UTC [51] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:36:49.959 UTC [51] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-08-17 14:36:50.025 UTC [51] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:50.078 UTC [51] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:50.152 UTC [51] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-08-17 14:36:50.203 UTC [51] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-08-17 14:36:50.220 UTC [51] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:50.274 UTC [51] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-08-17 14:36:50.305 UTC [51] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:50.353 UTC [51] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:50.408 UTC [51] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:50.469 UTC [51] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:50.547 UTC [51] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-08-17 14:36:50.552 UTC [51] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:50.560 UTC [51] LOG:  statement: /*
	  Warnings:
	
	  - Added the required column `carga_horaria` to the `Disciplina` table without a default value. This is not possible if the table is not empty.
	
	*/
	-- AlterTable
	ALTER TABLE "Disciplina" ADD COLUMN     "carga_horaria" INTEGER NOT NULL;
	
2023-08-17 14:36:50.565 UTC [51] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `ProfessorDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey";
	
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_professor_fkey";
	
	-- DropTable
	DROP TABLE "ProfessorDisciplina";
	
	-- CreateTable
	CREATE TABLE "ProfessorCursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_cursoDisciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorCursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_cursoDisciplina_fkey" FOREIGN KEY ("id_cursoDisciplina") REFERENCES "CursoDisciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:50.634 UTC [51] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `AlunoDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "AlunoDisciplina" DROP CONSTRAINT "AlunoDisciplina_id_aluno_fkey";
	
	-- DropForeignKey
	ALTER TABLE "AlunoDisciplina" DROP CONSTRAINT "AlunoDisciplina_id_disciplina_fkey";
	
	-- DropTable
	DROP TABLE "AlunoDisciplina";
	
2023-08-17 14:36:50.656 UTC [51] LOG:  execute s5: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-08-17 14:36:50.656 UTC [51] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:50.668 UTC [51] LOG:  execute s6: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-08-17 14:36:50.668 UTC [51] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:50.678 UTC [51] LOG:  execute s7: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-08-17 14:36:50.678 UTC [51] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:50.684 UTC [51] LOG:  execute s8: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-08-17 14:36:50.684 UTC [51] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:50.691 UTC [51] LOG:  execute s9: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-08-17 14:36:50.691 UTC [51] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:50.713 UTC [51] LOG:  execute s10: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-08-17 14:36:50.713 UTC [51] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:50.727 UTC [51] LOG:  execute s11: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-08-17 14:36:50.727 UTC [51] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:50.743 UTC [51] LOG:  execute s12: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-08-17 14:36:50.743 UTC [51] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:50.756 UTC [51] LOG:  execute s13: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-08-17 14:36:50.756 UTC [51] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:50.764 UTC [51] LOG:  execute s14: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-08-17 14:36:50.768 UTC [51] LOG:  execute s15: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-08-17 14:36:50.768 UTC [51] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:50.771 UTC [50] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_aba8a591-13b2-4ab1-b89a-a618edc3ee0b"
2023-08-17 14:36:50.777 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-08-17 14:36:51.018 UTC [28] LOG:  checkpoint complete: wrote 6 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.055 s, sync=0.019 s, total=0.242 s; sync files=6, longest=0.006 s, average=0.003 s; distance=4581 kB, estimate=4581 kB
2023-08-17 14:36:52.825 UTC [50] LOG:  execute s16: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-08-17 14:36:52.825 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:52.846 UTC [50] LOG:  execute s17: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-08-17 14:36:52.846 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:52.861 UTC [50] LOG:  execute s18: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-08-17 14:36:52.861 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:52.867 UTC [50] LOG:  execute s19: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-08-17 14:36:52.867 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:52.885 UTC [50] LOG:  execute s20: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-08-17 14:36:52.885 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:52.924 UTC [50] LOG:  execute s21: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-08-17 14:36:52.924 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:52.940 UTC [50] LOG:  execute s22: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-08-17 14:36:52.940 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:52.965 UTC [50] LOG:  execute s23: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-08-17 14:36:52.965 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:52.980 UTC [50] LOG:  execute s24: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-08-17 14:36:52.980 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:52.990 UTC [50] LOG:  execute s25: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-08-17 14:36:52.996 UTC [50] LOG:  execute s26: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-08-17 14:36:52.996 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:52.999 UTC [50] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_501cc121-87da-4331-ac50-456a4b828d30"
2023-08-17 14:36:56.178 UTC [52] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:36:56.181 UTC [52] LOG:  execute s27: SELECT version()
2023-08-17 14:36:56.189 UTC [52] LOG:  execute s28: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:36:56.189 UTC [52] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:36:56.191 UTC [52] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-08-17 14:36:56.247 UTC [52] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:56.301 UTC [52] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:56.369 UTC [52] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-08-17 14:36:56.421 UTC [52] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-08-17 14:36:56.439 UTC [52] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:56.488 UTC [52] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-08-17 14:36:56.516 UTC [52] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:56.564 UTC [52] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:56.613 UTC [52] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:56.668 UTC [52] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:56.733 UTC [52] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-08-17 14:36:56.737 UTC [52] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:56.746 UTC [52] LOG:  statement: /*
	  Warnings:
	
	  - Added the required column `carga_horaria` to the `Disciplina` table without a default value. This is not possible if the table is not empty.
	
	*/
	-- AlterTable
	ALTER TABLE "Disciplina" ADD COLUMN     "carga_horaria" INTEGER NOT NULL;
	
2023-08-17 14:36:56.751 UTC [52] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `ProfessorDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey";
	
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_professor_fkey";
	
	-- DropTable
	DROP TABLE "ProfessorDisciplina";
	
	-- CreateTable
	CREATE TABLE "ProfessorCursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_cursoDisciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorCursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_cursoDisciplina_fkey" FOREIGN KEY ("id_cursoDisciplina") REFERENCES "CursoDisciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:36:56.818 UTC [52] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `AlunoDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "AlunoDisciplina" DROP CONSTRAINT "AlunoDisciplina_id_aluno_fkey";
	
	-- DropForeignKey
	ALTER TABLE "AlunoDisciplina" DROP CONSTRAINT "AlunoDisciplina_id_disciplina_fkey";
	
	-- DropTable
	DROP TABLE "AlunoDisciplina";
	
2023-08-17 14:36:56.837 UTC [52] LOG:  execute s29: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-08-17 14:36:56.837 UTC [52] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:56.848 UTC [52] LOG:  execute s30: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-08-17 14:36:56.848 UTC [52] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:56.857 UTC [52] LOG:  execute s31: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-08-17 14:36:56.857 UTC [52] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:56.864 UTC [52] LOG:  execute s32: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-08-17 14:36:56.864 UTC [52] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:56.870 UTC [52] LOG:  execute s33: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-08-17 14:36:56.870 UTC [52] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:56.892 UTC [52] LOG:  execute s34: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-08-17 14:36:56.892 UTC [52] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:56.905 UTC [52] LOG:  execute s35: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-08-17 14:36:56.905 UTC [52] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:56.921 UTC [52] LOG:  execute s36: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-08-17 14:36:56.921 UTC [52] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:56.937 UTC [52] LOG:  execute s37: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-08-17 14:36:56.937 UTC [52] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:56.944 UTC [52] LOG:  execute s38: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-08-17 14:36:56.948 UTC [52] LOG:  execute s39: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-08-17 14:36:56.948 UTC [52] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:56.950 UTC [50] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_501cc121-87da-4331-ac50-456a4b828d30"
2023-08-17 14:36:57.064 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-08-17 14:36:57.196 UTC [28] LOG:  checkpoint complete: wrote 14 buffers (0.0%); 0 WAL file(s) added, 0 removed, 1 recycled; write=0.030 s, sync=0.015 s, total=0.133 s; sync files=13, longest=0.003 s, average=0.002 s; distance=4596 kB, estimate=4596 kB
2023-08-17 14:36:59.343 UTC [50] LOG:  statement: SELECT pg_advisory_lock(72707369)
2023-08-17 14:36:59.357 UTC [50] LOG:  execute s40: 
	                SELECT tbl.relname AS table_name
	                FROM pg_class AS tbl
	                INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	                WHERE tbl.relkind = 'r' AND namespace.nspname = ANY ( $1 )
	            
2023-08-17 14:36:59.357 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:36:59.365 UTC [50] LOG:  execute s41: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-08-17 14:36:59.371 UTC [50] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_f89a4e47-33d8-4515-9922-43c61b8c94fb"
2023-08-17 14:37:02.379 UTC [54] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:37:02.383 UTC [54] LOG:  execute s42: SELECT version()
2023-08-17 14:37:02.392 UTC [54] LOG:  execute s43: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:37:02.392 UTC [54] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:37:02.394 UTC [54] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-08-17 14:37:02.458 UTC [54] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:37:02.515 UTC [54] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:37:02.614 UTC [54] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-08-17 14:37:02.694 UTC [54] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-08-17 14:37:02.723 UTC [54] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:37:02.790 UTC [54] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-08-17 14:37:02.824 UTC [54] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:37:02.873 UTC [54] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:37:02.923 UTC [54] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:37:02.978 UTC [54] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:37:03.042 UTC [54] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-08-17 14:37:03.046 UTC [54] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:37:03.055 UTC [54] LOG:  statement: /*
	  Warnings:
	
	  - Added the required column `carga_horaria` to the `Disciplina` table without a default value. This is not possible if the table is not empty.
	
	*/
	-- AlterTable
	ALTER TABLE "Disciplina" ADD COLUMN     "carga_horaria" INTEGER NOT NULL;
	
2023-08-17 14:37:03.059 UTC [54] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `ProfessorDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey";
	
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_professor_fkey";
	
	-- DropTable
	DROP TABLE "ProfessorDisciplina";
	
	-- CreateTable
	CREATE TABLE "ProfessorCursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_cursoDisciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorCursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_cursoDisciplina_fkey" FOREIGN KEY ("id_cursoDisciplina") REFERENCES "CursoDisciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:37:03.126 UTC [54] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `AlunoDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "AlunoDisciplina" DROP CONSTRAINT "AlunoDisciplina_id_aluno_fkey";
	
	-- DropForeignKey
	ALTER TABLE "AlunoDisciplina" DROP CONSTRAINT "AlunoDisciplina_id_disciplina_fkey";
	
	-- DropTable
	DROP TABLE "AlunoDisciplina";
	
2023-08-17 14:37:03.146 UTC [54] LOG:  execute s44: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-08-17 14:37:03.146 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:37:03.156 UTC [54] LOG:  execute s45: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-08-17 14:37:03.156 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:37:03.166 UTC [54] LOG:  execute s46: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-08-17 14:37:03.166 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:37:03.173 UTC [54] LOG:  execute s47: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-08-17 14:37:03.173 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:37:03.180 UTC [54] LOG:  execute s48: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-08-17 14:37:03.180 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:37:03.202 UTC [54] LOG:  execute s49: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-08-17 14:37:03.202 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:37:03.216 UTC [54] LOG:  execute s50: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-08-17 14:37:03.216 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:37:03.233 UTC [54] LOG:  execute s51: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-08-17 14:37:03.233 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:37:03.246 UTC [54] LOG:  execute s52: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-08-17 14:37:03.246 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:37:03.254 UTC [54] LOG:  execute s53: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-08-17 14:37:03.258 UTC [54] LOG:  execute s54: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-08-17 14:37:03.258 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:37:03.260 UTC [50] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_f89a4e47-33d8-4515-9922-43c61b8c94fb"
2023-08-17 14:37:03.382 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-08-17 14:37:03.470 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.016 s, sync=0.007 s, total=0.089 s; sync files=4, longest=0.004 s, average=0.002 s; distance=4574 kB, estimate=4594 kB
2023-08-17 14:38:21.578 UTC [50] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_bee051ea-00cd-4315-aa4d-0828a461d3ee"
2023-08-17 14:38:24.864 UTC [56] LOG:  statement: SET search_path = "public";
	
2023-08-17 14:38:24.867 UTC [56] LOG:  execute s55: SELECT version()
2023-08-17 14:38:24.875 UTC [56] LOG:  execute s56: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-08-17 14:38:24.875 UTC [56] DETAIL:  parameters: $1 = 'public'
2023-08-17 14:38:24.877 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-08-17 14:38:24.983 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:38:25.072 UTC [56] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:38:25.204 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-08-17 14:38:25.296 UTC [56] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-08-17 14:38:25.334 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:38:25.414 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-08-17 14:38:25.477 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:38:25.544 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:38:25.631 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:38:25.717 UTC [56] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:38:25.842 UTC [56] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-08-17 14:38:25.855 UTC [56] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:38:25.875 UTC [56] LOG:  statement: /*
	  Warnings:
	
	  - Added the required column `carga_horaria` to the `Disciplina` table without a default value. This is not possible if the table is not empty.
	
	*/
	-- AlterTable
	ALTER TABLE "Disciplina" ADD COLUMN     "carga_horaria" INTEGER NOT NULL;
	
2023-08-17 14:38:25.888 UTC [56] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `ProfessorDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey";
	
	-- DropForeignKey
	ALTER TABLE "ProfessorDisciplina" DROP CONSTRAINT "ProfessorDisciplina_id_professor_fkey";
	
	-- DropTable
	DROP TABLE "ProfessorDisciplina";
	
	-- CreateTable
	CREATE TABLE "ProfessorCursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_cursoDisciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorCursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorCursoDisciplina" ADD CONSTRAINT "ProfessorCursoDisciplina_id_cursoDisciplina_fkey" FOREIGN KEY ("id_cursoDisciplina") REFERENCES "CursoDisciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:38:26.006 UTC [56] LOG:  statement: /*
	  Warnings:
	
	  - You are about to drop the `AlunoDisciplina` table. If the table is not empty, all the data it contains will be lost.
	
	*/
	-- DropForeignKey
	ALTER TABLE "AlunoDisciplina" DROP CONSTRAINT "AlunoDisciplina_id_aluno_fkey";
	
	-- DropForeignKey
	ALTER TABLE "AlunoDisciplina" DROP CONSTRAINT "AlunoDisciplina_id_disciplina_fkey";
	
	-- DropTable
	DROP TABLE "AlunoDisciplina";
	
2023-08-17 14:38:26.049 UTC [56] LOG:  execute s57: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-08-17 14:38:26.049 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:26.061 UTC [56] LOG:  execute s58: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-08-17 14:38:26.061 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:26.074 UTC [56] LOG:  execute s59: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-08-17 14:38:26.074 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:26.080 UTC [56] LOG:  execute s60: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-08-17 14:38:26.080 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:26.088 UTC [56] LOG:  execute s61: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-08-17 14:38:26.088 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:26.112 UTC [56] LOG:  execute s62: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-08-17 14:38:26.112 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:26.126 UTC [56] LOG:  execute s63: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-08-17 14:38:26.126 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:26.144 UTC [56] LOG:  execute s64: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-08-17 14:38:26.144 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:26.159 UTC [56] LOG:  execute s65: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-08-17 14:38:26.159 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:26.167 UTC [56] LOG:  execute s66: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-08-17 14:38:26.172 UTC [56] LOG:  execute s67: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-08-17 14:38:26.172 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:26.174 UTC [50] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_bee051ea-00cd-4315-aa4d-0828a461d3ee"
2023-08-17 14:38:26.281 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-08-17 14:38:26.510 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.039 s, sync=0.043 s, total=0.230 s; sync files=4, longest=0.013 s, average=0.011 s; distance=4574 kB, estimate=4592 kB
2023-08-17 14:38:28.382 UTC [50] LOG:  statement: SELECT pg_advisory_lock(72707369)
2023-08-17 14:38:28.396 UTC [50] LOG:  execute s68: 
	                SELECT tbl.relname AS table_name
	                FROM pg_class AS tbl
	                INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	                WHERE tbl.relkind = 'r' AND namespace.nspname = ANY ( $1 )
	            
2023-08-17 14:38:28.396 UTC [50] DETAIL:  parameters: $1 = '{public}'
2023-08-17 14:38:28.403 UTC [50] LOG:  execute s69: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-08-17 14:38:28.407 UTC [50] LOG:  execute s70: INSERT INTO "_prisma_migrations" ("id","checksum","started_at","migration_name") VALUES ($1,$2,$3,$4)
2023-08-17 14:38:28.407 UTC [50] DETAIL:  parameters: $1 = '45639bb7-c6b1-4762-8e1d-0d217515dc4a', $2 = 'e809c0fb15324bbe74299590cad47d8724163547df1a4aaee999b1b6161e4cdd', $3 = '2023-08-17 14:38:28.405675+00', $4 = '20230817143828_create_table_aluno_professor_curso_disciplina'
2023-08-17 14:38:28.412 UTC [50] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoProfessorCursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_professorCursoDisciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoProfessorCursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoProfessorCursoDisciplina" ADD CONSTRAINT "AlunoProfessorCursoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoProfessorCursoDisciplina" ADD CONSTRAINT "AlunoProfessorCursoDisciplina_id_professorCursoDisciplina_fkey" FOREIGN KEY ("id_professorCursoDisciplina") REFERENCES "ProfessorCursoDisciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-08-17 14:38:28.504 UTC [50] LOG:  execute s71: UPDATE "_prisma_migrations" SET "applied_steps_count" = ("applied_steps_count" + $1) WHERE "id" = $2
2023-08-17 14:38:28.504 UTC [50] DETAIL:  parameters: $1 = '1', $2 = '45639bb7-c6b1-4762-8e1d-0d217515dc4a'
2023-08-17 14:38:28.509 UTC [50] LOG:  execute s72: UPDATE "_prisma_migrations" SET "finished_at" = $1 WHERE "id" = $2
2023-08-17 14:38:28.509 UTC [50] DETAIL:  parameters: $1 = '2023-08-17 14:38:28.508628+00', $2 = '45639bb7-c6b1-4762-8e1d-0d217515dc4a'
2023-08-17 14:43:26.568 UTC [28] LOG:  checkpoint starting: time
2023-08-17 14:43:31.476 UTC [28] LOG:  checkpoint complete: wrote 48 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=4.814 s, sync=0.041 s, total=4.908 s; sync files=38, longest=0.004 s, average=0.002 s; distance=192 kB, estimate=4152 kB
