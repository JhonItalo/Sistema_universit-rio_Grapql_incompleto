2023-07-11 18:41:03.760 UTC [1] LOG:  starting PostgreSQL 15.3 (Debian 15.3-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
2023-07-11 18:41:03.761 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2023-07-11 18:41:03.761 UTC [1] LOG:  listening on IPv6 address "::", port 5432
2023-07-11 18:41:03.798 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2023-07-11 18:41:03.877 UTC [30] LOG:  database system was interrupted; last known up at 2023-07-11 13:25:03 UTC
2023-07-11 18:41:10.517 UTC [30] LOG:  database system was not properly shut down; automatic recovery in progress
2023-07-11 18:41:10.566 UTC [30] LOG:  redo starts at 0/4A82F60
2023-07-11 18:41:10.583 UTC [30] LOG:  invalid record length at 0/4A85AB8: wanted 24, got 0
2023-07-11 18:41:10.583 UTC [30] LOG:  redo done at 0/4A85A80 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.01 s
2023-07-11 18:41:10.656 UTC [28] LOG:  checkpoint starting: end-of-recovery immediate wait
2023-07-11 18:41:10.736 UTC [28] LOG:  checkpoint complete: wrote 9 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.024 s, sync=0.021 s, total=0.085 s; sync files=10, longest=0.004 s, average=0.003 s; distance=10 kB, estimate=10 kB
2023-07-11 18:41:10.785 UTC [1] LOG:  database system is ready to accept connections
2023-07-11 18:52:28.695 UTC [34] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:52:28.714 UTC [34] LOG:  execute s0: SELECT version()
2023-07-11 18:52:28.757 UTC [34] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:52:28.757 UTC [34] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:52:28.954 UTC [35] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:52:28.957 UTC [35] LOG:  execute s0: SELECT version()
2023-07-11 18:52:28.963 UTC [35] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:52:28.963 UTC [35] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:52:28.996 UTC [35] LOG:  execute s2: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-07-11 18:52:29.089 UTC [35] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_b55e630d-f922-4dd5-82cd-b855537c1b8f"
2023-07-11 18:52:33.952 UTC [36] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:52:33.955 UTC [36] LOG:  execute s3: SELECT version()
2023-07-11 18:52:33.964 UTC [36] LOG:  execute s4: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:52:33.964 UTC [36] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:52:33.966 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-11 18:52:34.079 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:34.166 UTC [36] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:34.306 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-11 18:52:34.412 UTC [36] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-11 18:52:34.449 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:34.534 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-11 18:52:34.596 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:34.667 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:34.763 UTC [36] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:34.867 UTC [36] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:34.989 UTC [36] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-11 18:52:35.006 UTC [36] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:35.028 UTC [36] LOG:  execute s5: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 18:52:35.028 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:35.046 UTC [36] LOG:  execute s6: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 18:52:35.046 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:35.062 UTC [36] LOG:  execute s7: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 18:52:35.062 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:35.070 UTC [36] LOG:  execute s8: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 18:52:35.070 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:35.080 UTC [36] LOG:  execute s9: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 18:52:35.080 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:35.119 UTC [36] LOG:  execute s10: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 18:52:35.119 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:35.147 UTC [36] LOG:  execute s11: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 18:52:35.147 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:35.184 UTC [36] LOG:  execute s12: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 18:52:35.184 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:35.201 UTC [36] LOG:  execute s13: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 18:52:35.201 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:35.212 UTC [36] LOG:  execute s14: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 18:52:35.217 UTC [36] LOG:  execute s15: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 18:52:35.217 UTC [36] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:35.220 UTC [35] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_b55e630d-f922-4dd5-82cd-b855537c1b8f"
2023-07-11 18:52:35.366 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-07-11 18:52:35.609 UTC [28] LOG:  checkpoint complete: wrote 5 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.041 s, sync=0.054 s, total=0.244 s; sync files=5, longest=0.013 s, average=0.011 s; distance=4529 kB, estimate=4529 kB
2023-07-11 18:52:38.191 UTC [35] LOG:  execute s16: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 18:52:38.191 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:38.226 UTC [35] LOG:  execute s17: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 18:52:38.226 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:38.262 UTC [35] LOG:  execute s18: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 18:52:38.262 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:38.291 UTC [35] LOG:  execute s19: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 18:52:38.291 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:38.319 UTC [35] LOG:  execute s20: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 18:52:38.319 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:38.445 UTC [35] LOG:  execute s21: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 18:52:38.445 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:38.505 UTC [35] LOG:  execute s22: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 18:52:38.505 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:38.556 UTC [35] LOG:  execute s23: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 18:52:38.556 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:38.585 UTC [35] LOG:  execute s24: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 18:52:38.585 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:38.642 UTC [35] LOG:  execute s25: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 18:52:38.652 UTC [35] LOG:  execute s26: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 18:52:38.652 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:38.658 UTC [35] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_efc7942c-af40-427c-8e45-35689bca29bd"
2023-07-11 18:52:42.383 UTC [38] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:52:42.386 UTC [38] LOG:  execute s27: SELECT version()
2023-07-11 18:52:42.396 UTC [38] LOG:  execute s28: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:52:42.396 UTC [38] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:52:42.399 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-11 18:52:42.475 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:42.540 UTC [38] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:42.643 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-11 18:52:42.711 UTC [38] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-11 18:52:42.733 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:42.802 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-11 18:52:42.843 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:42.904 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:42.967 UTC [38] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:43.043 UTC [38] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:43.127 UTC [38] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-11 18:52:43.133 UTC [38] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:43.147 UTC [38] LOG:  execute s29: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 18:52:43.147 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:43.160 UTC [38] LOG:  execute s30: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 18:52:43.160 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:43.175 UTC [38] LOG:  execute s31: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 18:52:43.175 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:43.183 UTC [38] LOG:  execute s32: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 18:52:43.183 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:43.197 UTC [38] LOG:  execute s33: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 18:52:43.197 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:43.235 UTC [38] LOG:  execute s34: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 18:52:43.235 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:43.261 UTC [38] LOG:  execute s35: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 18:52:43.261 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:43.284 UTC [38] LOG:  execute s36: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 18:52:43.284 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:43.308 UTC [38] LOG:  execute s37: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 18:52:43.308 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:43.318 UTC [38] LOG:  execute s38: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 18:52:43.325 UTC [38] LOG:  execute s39: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 18:52:43.325 UTC [38] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:43.327 UTC [35] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_efc7942c-af40-427c-8e45-35689bca29bd"
2023-07-11 18:52:43.445 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-07-11 18:52:43.582 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 1 recycled; write=0.025 s, sync=0.008 s, total=0.138 s; sync files=4, longest=0.004 s, average=0.002 s; distance=4527 kB, estimate=4529 kB
2023-07-11 18:52:46.128 UTC [35] LOG:  statement: SELECT pg_advisory_lock(72707369)
2023-07-11 18:52:46.144 UTC [35] LOG:  execute s40: 
	                SELECT tbl.relname AS table_name
	                FROM pg_class AS tbl
	                INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	                WHERE tbl.relkind = 'r' AND namespace.nspname = ANY ( $1 )
	            
2023-07-11 18:52:46.144 UTC [35] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:46.151 UTC [35] LOG:  execute s41: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-07-11 18:52:46.159 UTC [35] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_832a6afa-d232-4244-b041-8d41a8d3300f"
2023-07-11 18:52:49.850 UTC [39] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:52:49.854 UTC [39] LOG:  execute s42: SELECT version()
2023-07-11 18:52:49.865 UTC [39] LOG:  execute s43: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:52:49.865 UTC [39] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:52:49.867 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-11 18:52:49.939 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:49.995 UTC [39] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:50.074 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-11 18:52:50.132 UTC [39] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-11 18:52:50.151 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:50.211 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-11 18:52:50.263 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:50.312 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:50.373 UTC [39] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:50.442 UTC [39] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:50.520 UTC [39] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-11 18:52:50.526 UTC [39] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:52:50.537 UTC [39] LOG:  execute s44: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 18:52:50.537 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:50.551 UTC [39] LOG:  execute s45: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 18:52:50.551 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:50.563 UTC [39] LOG:  execute s46: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 18:52:50.563 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:50.569 UTC [39] LOG:  execute s47: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 18:52:50.569 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:50.577 UTC [39] LOG:  execute s48: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 18:52:50.577 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:50.604 UTC [39] LOG:  execute s49: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 18:52:50.604 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:50.629 UTC [39] LOG:  execute s50: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 18:52:50.629 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:50.652 UTC [39] LOG:  execute s51: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 18:52:50.652 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:50.670 UTC [39] LOG:  execute s52: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 18:52:50.670 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:50.680 UTC [39] LOG:  execute s53: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 18:52:50.691 UTC [39] LOG:  execute s54: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 18:52:50.691 UTC [39] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:52:50.694 UTC [35] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_832a6afa-d232-4244-b041-8d41a8d3300f"
2023-07-11 18:52:50.829 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-07-11 18:52:51.083 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.028 s, sync=0.007 s, total=0.255 s; sync files=4, longest=0.004 s, average=0.002 s; distance=4527 kB, estimate=4528 kB
2023-07-11 18:52:54.102 UTC [35] LOG:  execute s55: SELECT COUNT(*) FROM "Disciplina"
2023-07-11 18:56:00.962 UTC [42] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:56:00.966 UTC [42] LOG:  execute s0: SELECT version()
2023-07-11 18:56:00.974 UTC [42] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:56:00.974 UTC [42] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:56:01.213 UTC [43] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:56:01.216 UTC [43] LOG:  execute s0: SELECT version()
2023-07-11 18:56:01.222 UTC [43] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:56:01.222 UTC [43] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:56:01.230 UTC [43] LOG:  execute s2: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-07-11 18:56:01.235 UTC [43] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_63c3ff0f-d5e6-4411-a591-25a55e79dd17"
2023-07-11 18:56:04.761 UTC [44] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:56:04.764 UTC [44] LOG:  execute s3: SELECT version()
2023-07-11 18:56:04.772 UTC [44] LOG:  execute s4: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:56:04.772 UTC [44] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:56:04.774 UTC [44] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-11 18:56:04.832 UTC [44] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:04.888 UTC [44] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:04.958 UTC [44] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-11 18:56:05.023 UTC [44] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-11 18:56:05.039 UTC [44] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:05.087 UTC [44] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-11 18:56:05.120 UTC [44] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:05.158 UTC [44] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:05.203 UTC [44] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:05.273 UTC [44] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:05.336 UTC [44] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-11 18:56:05.340 UTC [44] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:05.349 UTC [44] LOG:  execute s5: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 18:56:05.349 UTC [44] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:05.360 UTC [44] LOG:  execute s6: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 18:56:05.360 UTC [44] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:05.371 UTC [44] LOG:  execute s7: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 18:56:05.371 UTC [44] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:05.378 UTC [44] LOG:  execute s8: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 18:56:05.378 UTC [44] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:05.386 UTC [44] LOG:  execute s9: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 18:56:05.386 UTC [44] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:05.422 UTC [44] LOG:  execute s10: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 18:56:05.422 UTC [44] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:05.440 UTC [44] LOG:  execute s11: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 18:56:05.440 UTC [44] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:05.463 UTC [44] LOG:  execute s12: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 18:56:05.463 UTC [44] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:05.476 UTC [44] LOG:  execute s13: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 18:56:05.476 UTC [44] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:05.484 UTC [44] LOG:  execute s14: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 18:56:05.489 UTC [44] LOG:  execute s15: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 18:56:05.489 UTC [44] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:05.492 UTC [43] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_63c3ff0f-d5e6-4411-a591-25a55e79dd17"
2023-07-11 18:56:05.600 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-07-11 18:56:05.733 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.022 s, sync=0.007 s, total=0.133 s; sync files=4, longest=0.004 s, average=0.002 s; distance=4527 kB, estimate=4528 kB
2023-07-11 18:56:07.838 UTC [45] FATAL:  database "prisma_migrate_shadow_db_63c3ff0f-d5e6-4411-a591-25a55e79dd17" does not exist
2023-07-11 18:56:07.838 UTC [45] DETAIL:  It seems to have just been dropped or renamed.
2023-07-11 18:56:07.845 UTC [43] LOG:  execute s16: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 18:56:07.845 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:07.867 UTC [43] LOG:  execute s17: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 18:56:07.867 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:07.880 UTC [43] LOG:  execute s18: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 18:56:07.880 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:07.886 UTC [43] LOG:  execute s19: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 18:56:07.886 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:07.899 UTC [43] LOG:  execute s20: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 18:56:07.899 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:07.950 UTC [43] LOG:  execute s21: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 18:56:07.950 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:07.966 UTC [43] LOG:  execute s22: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 18:56:07.966 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:07.983 UTC [43] LOG:  execute s23: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 18:56:07.983 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:07.995 UTC [43] LOG:  execute s24: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 18:56:07.995 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:08.002 UTC [43] LOG:  execute s25: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 18:56:08.006 UTC [43] LOG:  execute s26: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 18:56:08.006 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:08.009 UTC [43] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_4f97789b-a65f-4548-8154-3facaa0ce9ae"
2023-07-11 18:56:11.701 UTC [46] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:56:11.704 UTC [46] LOG:  execute s27: SELECT version()
2023-07-11 18:56:11.714 UTC [46] LOG:  execute s28: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:56:11.714 UTC [46] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:56:11.717 UTC [46] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-11 18:56:11.794 UTC [46] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:11.852 UTC [46] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:11.953 UTC [46] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-11 18:56:12.010 UTC [46] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-11 18:56:12.028 UTC [46] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:12.084 UTC [46] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-11 18:56:12.131 UTC [46] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:12.189 UTC [46] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:12.239 UTC [46] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:12.295 UTC [46] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:12.359 UTC [46] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-11 18:56:12.363 UTC [46] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:12.371 UTC [46] LOG:  execute s29: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 18:56:12.371 UTC [46] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:12.382 UTC [46] LOG:  execute s30: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 18:56:12.382 UTC [46] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:12.391 UTC [46] LOG:  execute s31: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 18:56:12.391 UTC [46] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:12.396 UTC [46] LOG:  execute s32: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 18:56:12.396 UTC [46] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:12.402 UTC [46] LOG:  execute s33: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 18:56:12.402 UTC [46] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:12.436 UTC [46] LOG:  execute s34: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 18:56:12.436 UTC [46] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:12.449 UTC [46] LOG:  execute s35: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 18:56:12.449 UTC [46] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:12.465 UTC [46] LOG:  execute s36: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 18:56:12.465 UTC [46] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:12.478 UTC [46] LOG:  execute s37: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 18:56:12.478 UTC [46] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:12.484 UTC [46] LOG:  execute s38: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 18:56:12.488 UTC [46] LOG:  execute s39: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 18:56:12.488 UTC [46] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:12.490 UTC [43] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_4f97789b-a65f-4548-8154-3facaa0ce9ae"
2023-07-11 18:56:12.494 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-07-11 18:56:12.673 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 1 recycled; write=0.071 s, sync=0.007 s, total=0.180 s; sync files=4, longest=0.003 s, average=0.002 s; distance=4527 kB, estimate=4528 kB
2023-07-11 18:56:14.823 UTC [43] LOG:  statement: SELECT pg_advisory_lock(72707369)
2023-07-11 18:56:14.834 UTC [43] LOG:  execute s40: 
	                SELECT tbl.relname AS table_name
	                FROM pg_class AS tbl
	                INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	                WHERE tbl.relkind = 'r' AND namespace.nspname = ANY ( $1 )
	            
2023-07-11 18:56:14.834 UTC [43] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:14.840 UTC [43] LOG:  execute s41: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-07-11 18:56:14.846 UTC [43] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_7e8c37a2-8f21-460f-aa43-0d0434b960e8"
2023-07-11 18:56:18.092 UTC [47] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:56:18.096 UTC [47] LOG:  execute s42: SELECT version()
2023-07-11 18:56:18.104 UTC [47] LOG:  execute s43: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:56:18.104 UTC [47] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:56:18.106 UTC [47] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-11 18:56:18.162 UTC [47] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:18.211 UTC [47] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:18.281 UTC [47] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-11 18:56:18.350 UTC [47] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-11 18:56:18.365 UTC [47] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:18.409 UTC [47] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-11 18:56:18.441 UTC [47] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:18.481 UTC [47] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:18.525 UTC [47] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:18.601 UTC [47] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:18.683 UTC [47] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-11 18:56:18.687 UTC [47] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:56:18.697 UTC [47] LOG:  execute s44: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 18:56:18.697 UTC [47] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:18.707 UTC [47] LOG:  execute s45: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 18:56:18.707 UTC [47] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:18.716 UTC [47] LOG:  execute s46: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 18:56:18.716 UTC [47] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:18.721 UTC [47] LOG:  execute s47: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 18:56:18.721 UTC [47] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:18.728 UTC [47] LOG:  execute s48: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 18:56:18.728 UTC [47] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:18.750 UTC [47] LOG:  execute s49: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 18:56:18.750 UTC [47] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:18.766 UTC [47] LOG:  execute s50: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 18:56:18.766 UTC [47] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:18.786 UTC [47] LOG:  execute s51: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 18:56:18.786 UTC [47] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:18.816 UTC [47] LOG:  execute s52: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 18:56:18.816 UTC [47] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:18.825 UTC [47] LOG:  execute s53: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 18:56:18.831 UTC [47] LOG:  execute s54: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 18:56:18.831 UTC [47] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:56:18.833 UTC [43] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_7e8c37a2-8f21-460f-aa43-0d0434b960e8"
2023-07-11 18:56:18.843 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-07-11 18:56:19.027 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.025 s, sync=0.006 s, total=0.185 s; sync files=4, longest=0.003 s, average=0.002 s; distance=4528 kB, estimate=4528 kB
2023-07-11 18:56:22.084 UTC [43] LOG:  execute s55: SELECT COUNT(*) FROM "Disciplina"
2023-07-11 18:57:36.692 UTC [50] LOG:  statement: SELECT CURRENT_SCHEMA() AS schema
2023-07-11 18:57:36.697 UTC [50] LOG:  statement: select version()
2023-07-11 18:57:36.700 UTC [50] LOG:  statement: 
	      SELECT      n.nspname as schema, t.typname as typename, t.oid::int4 as typeid
	      FROM        pg_type t
	      LEFT JOIN   pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	      WHERE       (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid))
	      AND     NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
	      AND     n.nspname NOT IN ('pg_catalog', 'information_schema');
	    
2023-07-11 18:57:36.725 UTC [50] LOG:  statement: select version()
2023-07-11 18:57:36.976 UTC [50] LOG:  execute <unnamed>: 
	    SELECT datname
	    FROM pg_database
	    WHERE datistemplate = $1
	    
	    ORDER BY datname
	  
2023-07-11 18:57:36.976 UTC [50] DETAIL:  parameters: $1 = 'f'
2023-07-11 18:57:37.334 UTC [51] LOG:  statement: select version()
2023-07-11 18:57:37.342 UTC [51] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-11 18:57:37.380 UTC [51] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-11 18:57:37.395 UTC [51] LOG:  statement: select version()
2023-07-11 18:57:37.398 UTC [51] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-11 18:57:37.480 UTC [51] LOG:  statement: select version()
2023-07-11 18:57:37.497 UTC [51] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-11 18:57:37.535 UTC [51] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-11 18:57:42.756 UTC [51] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-11 18:57:42.756 UTC [51] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-11 18:57:42.825 UTC [51] LOG:  execute <unnamed>: 
	    SELECT
	        tc.table_schema as from_schema,
	        tc.table_name as from_table,
	        kcu.column_name as from_column,
	        ccu.table_schema AS to_schema,
	        ccu.table_name AS to_table,
	        ccu.column_name AS to_column,
	        tc.constraint_name,
	        rc.update_rule as update_rule,
	        rc.delete_rule as delete_rule
	    FROM
	        information_schema.table_constraints AS tc
	        JOIN information_schema.key_column_usage AS kcu
	          ON tc.constraint_name = kcu.constraint_name
	          AND tc.table_schema = kcu.table_schema
	        JOIN information_schema.constraint_column_usage AS ccu
	          ON ccu.constraint_name = tc.constraint_name
	          AND ccu.table_schema = tc.table_schema
	         JOIN information_schema.referential_constraints rc
	          on tc.constraint_name = rc.constraint_name
	          and tc.table_schema = rc.constraint_schema
	    WHERE tc.constraint_type = 'FOREIGN KEY'
	    AND tc.table_name= $1 and tc.table_schema = $2;
	
	  
2023-07-11 18:57:42.825 UTC [51] DETAIL:  parameters: $1 = 'Disciplina', $2 = 'public'
2023-07-11 18:57:42.828 UTC [51] LOG:  statement: select version()
2023-07-11 18:57:42.831 UTC [51] LOG:  statement: 
	    SELECT
	      a.attname as column_name,
	      format_type(a.atttypid, a.atttypmod) AS data_type,
	      a.attnum as position
	    FROM   pg_index i
	    JOIN   pg_attribute a ON a.attrelid = i.indrelid
	                        AND a.attnum = ANY(i.indkey)
	    WHERE  i.indrelid = '"public"."Disciplina"'::regclass
	    AND    i.indisprimary
	    ORDER BY a.attnum
	  
2023-07-11 18:57:42.916 UTC [51] LOG:  statement: select version()
2023-07-11 18:57:42.931 UTC [51] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-11 18:57:45.172 UTC [51] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-11 18:57:45.172 UTC [51] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-11 18:59:45.705 UTC [52] LOG:  statement: BEGIN
2023-07-11 18:59:45.707 UTC [52] LOG:  statement: 
2023-07-11 18:59:45.710 UTC [52] LOG:  statement: 
2023-07-11 18:59:45.713 UTC [52] LOG:  statement: 
2023-07-11 18:59:45.719 UTC [52] LOG:  statement: delete from "public"."Disciplina" where "id" = 4;delete from "public"."Disciplina" where "id" = 3;delete from "public"."Disciplina" where "id" = 1;delete from "public"."Disciplina" where "id" = 2
2023-07-11 18:59:45.746 UTC [52] LOG:  statement: COMMIT
2023-07-11 18:59:45.769 UTC [52] LOG:  statement: select version()
2023-07-11 18:59:45.776 UTC [52] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-11 18:59:54.169 UTC [53] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:59:54.172 UTC [53] LOG:  execute s0: SELECT version()
2023-07-11 18:59:54.180 UTC [53] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:59:54.180 UTC [53] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:59:54.361 UTC [54] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:59:54.364 UTC [54] LOG:  execute s0: SELECT version()
2023-07-11 18:59:54.370 UTC [54] LOG:  execute s1: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:59:54.370 UTC [54] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:59:54.376 UTC [54] LOG:  execute s2: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-07-11 18:59:54.380 UTC [54] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_d8bd50a3-4f9f-4804-a9d9-6082f9932c5b"
2023-07-11 18:59:57.349 UTC [55] LOG:  statement: SET search_path = "public";
	
2023-07-11 18:59:57.352 UTC [55] LOG:  execute s3: SELECT version()
2023-07-11 18:59:57.360 UTC [55] LOG:  execute s4: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 18:59:57.360 UTC [55] DETAIL:  parameters: $1 = 'public'
2023-07-11 18:59:57.362 UTC [55] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-11 18:59:57.422 UTC [55] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:59:57.475 UTC [55] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:59:57.548 UTC [55] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-11 18:59:57.595 UTC [55] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-11 18:59:57.610 UTC [55] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:59:57.656 UTC [55] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-11 18:59:57.692 UTC [55] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:59:57.743 UTC [55] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:59:57.793 UTC [55] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:59:57.850 UTC [55] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:59:57.916 UTC [55] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-11 18:59:57.920 UTC [55] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 18:59:57.930 UTC [55] LOG:  execute s5: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 18:59:57.930 UTC [55] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:59:57.940 UTC [55] LOG:  execute s6: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 18:59:57.940 UTC [55] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:59:57.950 UTC [55] LOG:  execute s7: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 18:59:57.950 UTC [55] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:59:57.955 UTC [55] LOG:  execute s8: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 18:59:57.955 UTC [55] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:59:57.961 UTC [55] LOG:  execute s9: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 18:59:57.961 UTC [55] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:59:57.982 UTC [55] LOG:  execute s10: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 18:59:57.982 UTC [55] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:59:57.998 UTC [55] LOG:  execute s11: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 18:59:57.998 UTC [55] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:59:58.014 UTC [55] LOG:  execute s12: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 18:59:58.014 UTC [55] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:59:58.029 UTC [55] LOG:  execute s13: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 18:59:58.029 UTC [55] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:59:58.035 UTC [55] LOG:  execute s14: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 18:59:58.039 UTC [55] LOG:  execute s15: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 18:59:58.039 UTC [55] DETAIL:  parameters: $1 = '{public}'
2023-07-11 18:59:58.041 UTC [54] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_d8bd50a3-4f9f-4804-a9d9-6082f9932c5b"
2023-07-11 18:59:58.147 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-07-11 18:59:58.244 UTC [28] LOG:  checkpoint complete: wrote 7 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.021 s, sync=0.010 s, total=0.097 s; sync files=7, longest=0.003 s, average=0.002 s; distance=4528 kB, estimate=4528 kB
2023-07-11 19:00:00.561 UTC [54] LOG:  execute s16: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 19:00:00.561 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:00.579 UTC [54] LOG:  execute s17: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 19:00:00.579 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:00.590 UTC [54] LOG:  execute s18: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 19:00:00.590 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:00.599 UTC [54] LOG:  execute s19: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 19:00:00.599 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:00.614 UTC [54] LOG:  execute s20: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 19:00:00.614 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:00.656 UTC [54] LOG:  execute s21: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 19:00:00.656 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:00.681 UTC [54] LOG:  execute s22: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 19:00:00.681 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:00.707 UTC [54] LOG:  execute s23: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 19:00:00.707 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:00.723 UTC [54] LOG:  execute s24: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 19:00:00.723 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:00.735 UTC [54] LOG:  execute s25: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 19:00:00.740 UTC [54] LOG:  execute s26: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 19:00:00.740 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:00.745 UTC [54] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_cc2ce2c7-5a47-4d35-8b6f-7310b0983ab6"
2023-07-11 19:00:06.216 UTC [56] LOG:  statement: SET search_path = "public";
	
2023-07-11 19:00:06.219 UTC [56] LOG:  execute s27: SELECT version()
2023-07-11 19:00:06.230 UTC [56] LOG:  execute s28: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 19:00:06.230 UTC [56] DETAIL:  parameters: $1 = 'public'
2023-07-11 19:00:06.232 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-11 19:00:06.310 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:06.400 UTC [56] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:06.514 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-11 19:00:06.579 UTC [56] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-11 19:00:06.604 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:06.683 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-11 19:00:06.721 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:06.957 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:07.051 UTC [56] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:07.164 UTC [56] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:07.279 UTC [56] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-11 19:00:07.283 UTC [56] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:07.294 UTC [56] LOG:  execute s29: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 19:00:07.294 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:07.307 UTC [56] LOG:  execute s30: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 19:00:07.307 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:07.321 UTC [56] LOG:  execute s31: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 19:00:07.321 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:07.328 UTC [56] LOG:  execute s32: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 19:00:07.328 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:07.337 UTC [56] LOG:  execute s33: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 19:00:07.337 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:07.366 UTC [56] LOG:  execute s34: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 19:00:07.366 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:07.380 UTC [56] LOG:  execute s35: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 19:00:07.380 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:07.398 UTC [56] LOG:  execute s36: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 19:00:07.398 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:07.411 UTC [56] LOG:  execute s37: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 19:00:07.411 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:07.419 UTC [56] LOG:  execute s38: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 19:00:07.423 UTC [56] LOG:  execute s39: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 19:00:07.423 UTC [56] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:07.425 UTC [54] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_cc2ce2c7-5a47-4d35-8b6f-7310b0983ab6"
2023-07-11 19:00:07.431 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-07-11 19:00:07.683 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.040 s, sync=0.006 s, total=0.252 s; sync files=4, longest=0.004 s, average=0.002 s; distance=4528 kB, estimate=4528 kB
2023-07-11 19:00:09.402 UTC [54] LOG:  statement: SELECT pg_advisory_lock(72707369)
2023-07-11 19:00:09.421 UTC [54] LOG:  execute s40: 
	                SELECT tbl.relname AS table_name
	                FROM pg_class AS tbl
	                INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	                WHERE tbl.relkind = 'r' AND namespace.nspname = ANY ( $1 )
	            
2023-07-11 19:00:09.421 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:09.429 UTC [54] LOG:  execute s41: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-07-11 19:00:09.435 UTC [54] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_94912538-9111-4405-bbff-20f8c24e4361"
2023-07-11 19:00:13.502 UTC [57] LOG:  statement: SET search_path = "public";
	
2023-07-11 19:00:13.506 UTC [57] LOG:  execute s42: SELECT version()
2023-07-11 19:00:13.518 UTC [57] LOG:  execute s43: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 19:00:13.518 UTC [57] DETAIL:  parameters: $1 = 'public'
2023-07-11 19:00:13.521 UTC [57] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-11 19:00:13.611 UTC [57] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:13.686 UTC [57] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:13.820 UTC [57] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-11 19:00:13.878 UTC [57] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-11 19:00:13.898 UTC [57] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:13.963 UTC [57] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-11 19:00:14.008 UTC [57] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:14.086 UTC [57] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:14.152 UTC [57] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:14.220 UTC [57] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:14.317 UTC [57] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-11 19:00:14.324 UTC [57] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:00:14.339 UTC [57] LOG:  execute s44: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 19:00:14.339 UTC [57] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:14.356 UTC [57] LOG:  execute s45: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 19:00:14.356 UTC [57] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:14.384 UTC [57] LOG:  execute s46: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 19:00:14.384 UTC [57] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:14.391 UTC [57] LOG:  execute s47: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 19:00:14.391 UTC [57] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:14.400 UTC [57] LOG:  execute s48: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 19:00:14.400 UTC [57] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:14.451 UTC [57] LOG:  execute s49: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 19:00:14.451 UTC [57] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:14.480 UTC [57] LOG:  execute s50: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 19:00:14.480 UTC [57] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:14.513 UTC [57] LOG:  execute s51: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 19:00:14.513 UTC [57] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:14.533 UTC [57] LOG:  execute s52: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 19:00:14.533 UTC [57] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:14.544 UTC [57] LOG:  execute s53: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 19:00:14.549 UTC [57] LOG:  execute s54: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 19:00:14.549 UTC [57] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:00:14.552 UTC [54] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_94912538-9111-4405-bbff-20f8c24e4361"
2023-07-11 19:00:14.665 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-07-11 19:00:14.812 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 1 recycled; write=0.041 s, sync=0.008 s, total=0.147 s; sync files=4, longest=0.004 s, average=0.002 s; distance=4528 kB, estimate=4528 kB
2023-07-11 19:00:17.680 UTC [54] LOG:  execute s55: SELECT COUNT(*) FROM "Disciplina"
2023-07-11 19:00:57.946 UTC [54] LOG:  statement: CREATE DATABASE "prisma_migrate_shadow_db_59511d51-73cc-47aa-8372-43b382fbd672"
2023-07-11 19:01:01.161 UTC [58] LOG:  statement: SET search_path = "public";
	
2023-07-11 19:01:01.165 UTC [58] LOG:  execute s56: SELECT version()
2023-07-11 19:01:01.175 UTC [58] LOG:  execute s57: SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1), version(), current_setting('server_version_num')::integer as numeric_version;
2023-07-11 19:01:01.175 UTC [58] DETAIL:  parameters: $1 = 'public'
2023-07-11 19:01:01.177 UTC [58] LOG:  statement: -- CreateTable
	CREATE TABLE "Departamento" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	
	    CONSTRAINT "Departamento_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Departamento_nome_key" ON "Departamento"("nome");
	
2023-07-11 19:01:01.236 UTC [58] LOG:  statement: -- CreateTable
	CREATE TABLE "Curso" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR(15) NOT NULL,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Curso_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Curso_nome_key" ON "Curso"("nome");
	
	-- AddForeignKey
	ALTER TABLE "Curso" ADD CONSTRAINT "Curso_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:01:01.286 UTC [58] LOG:  statement: -- CreateEnum
	CREATE TYPE "Sexo" AS ENUM ('M', 'F');
	
	-- CreateTable
	CREATE TABLE "Professor" (
	    "id" TEXT NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createt_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_departamento" INTEGER NOT NULL,
	
	    CONSTRAINT "Professor_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_email_key" ON "Professor"("email");
	
	-- CreateIndex
	CREATE UNIQUE INDEX "Professor_cpf_key" ON "Professor"("cpf");
	
	-- AddForeignKey
	ALTER TABLE "Professor" ADD CONSTRAINT "Professor_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:01:01.349 UTC [58] LOG:  statement: -- CreateTable
	CREATE TABLE "Turma" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Turma_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
	
2023-07-11 19:01:01.394 UTC [58] LOG:  statement: /*
	  Warnings:
	
	  - The primary key for the `Professor` table will be changed. If it partially fails, the table could be left without primary key constraint.
	
	*/
	-- AlterTable
	ALTER TABLE "Professor" DROP CONSTRAINT "Professor_pkey",
	ALTER COLUMN "id" SET DATA TYPE VARCHAR,
	ADD CONSTRAINT "Professor_pkey" PRIMARY KEY ("id");
	
2023-07-11 19:01:01.410 UTC [58] LOG:  statement: -- CreateTable
	CREATE TABLE "Aluno" (
	    "id" VARCHAR NOT NULL,
	    "nome" VARCHAR NOT NULL,
	    "email" VARCHAR(25) NOT NULL,
	    "cpf" VARCHAR(15) NOT NULL,
	    "sexo" "Sexo" NOT NULL,
	    "telefone" VARCHAR NOT NULL,
	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
	    "id_turma" INTEGER NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	
	    CONSTRAINT "Aluno_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_turma_fkey" FOREIGN KEY ("id_turma") REFERENCES "Turma"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "Aluno" ADD CONSTRAINT "Aluno_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:01:01.456 UTC [58] LOG:  statement: -- CreateTable
	CREATE TABLE "Disciplina" (
	    "id" SERIAL NOT NULL,
	    "nome" VARCHAR NOT NULL,
	
	    CONSTRAINT "Disciplina_pkey" PRIMARY KEY ("id")
	);
	
2023-07-11 19:01:01.487 UTC [58] LOG:  statement: -- CreateTable
	CREATE TABLE "CursoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_curso" INTEGER NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "CursoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "CursoDisciplina" ADD CONSTRAINT "CursoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:01:01.530 UTC [58] LOG:  statement: -- CreateTable
	CREATE TABLE "AlunoDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_aluno" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "AlunoDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "AlunoDisciplina" ADD CONSTRAINT "AlunoDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:01:01.579 UTC [58] LOG:  statement: -- CreateTable
	CREATE TABLE "ProfessorDisciplina" (
	    "id" SERIAL NOT NULL,
	    "id_professor" TEXT NOT NULL,
	    "id_disciplina" INTEGER NOT NULL,
	
	    CONSTRAINT "ProfessorDisciplina_pkey" PRIMARY KEY ("id")
	);
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "ProfessorDisciplina" ADD CONSTRAINT "ProfessorDisciplina_id_disciplina_fkey" FOREIGN KEY ("id_disciplina") REFERENCES "Disciplina"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:01:01.640 UTC [58] LOG:  statement: -- CreateEnum
	CREATE TYPE "UserStatus" AS ENUM ('departamento', 'professor', 'aluno');
	
	-- CreateTable
	CREATE TABLE "User" (
	    "id" TEXT NOT NULL,
	    "email" VARCHAR NOT NULL,
	    "password" VARCHAR NOT NULL,
	    "status" "UserStatus" NOT NULL,
	    "id_departamento" INTEGER,
	    "id_professor" TEXT,
	    "id_aluno" TEXT,
	
	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
	);
	
	-- CreateIndex
	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_departamento_fkey" FOREIGN KEY ("id_departamento") REFERENCES "Departamento"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_professor_fkey" FOREIGN KEY ("id_professor") REFERENCES "Professor"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
	-- AddForeignKey
	ALTER TABLE "User" ADD CONSTRAINT "User_id_aluno_fkey" FOREIGN KEY ("id_aluno") REFERENCES "Aluno"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:01:01.706 UTC [58] LOG:  statement: -- AlterTable
	ALTER TABLE "Curso" ALTER COLUMN "nome" SET DATA TYPE VARCHAR(40);
	
2023-07-11 19:01:01.710 UTC [58] LOG:  statement: -- DropForeignKey
	ALTER TABLE "Turma" DROP CONSTRAINT "Turma_id_curso_fkey";
	
	-- AddForeignKey
	ALTER TABLE "Turma" ADD CONSTRAINT "Turma_id_curso_fkey" FOREIGN KEY ("id_curso") REFERENCES "Curso"("id") ON DELETE CASCADE ON UPDATE CASCADE;
	
2023-07-11 19:01:01.720 UTC [58] LOG:  execute s58: SELECT namespace.nspname as namespace_name
	FROM pg_namespace as namespace
	WHERE namespace.nspname = ANY ( $1 )
	ORDER BY namespace_name;
	
2023-07-11 19:01:01.720 UTC [58] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:01.730 UTC [58] LOG:  execute s59: SELECT
	  tbl.relname AS table_name,
	  namespace.nspname as namespace,
	  (tbl.relhassubclass and tbl.relkind = 'p') as is_partition,
	  (tbl.relhassubclass and tbl.relkind = 'r') as has_subclass,
	  tbl.relrowsecurity as has_row_level_security,
	  reloptions,
	  pd.description as description
	FROM pg_class AS tbl
	INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	LEFT JOIN pg_description pd ON pd.objoid = tbl.oid AND pd.objsubid = 0
	WHERE
	  ( -- (relkind = 'r' and relispartition = 't') matches partition table "duplicates"
	    (tbl.relkind = 'r' AND tbl.relispartition = 'f')
	      OR -- when it's a partition
	    tbl.relkind = 'p'
	  )
	  AND namespace.nspname = ANY ( $1 )
	ORDER BY namespace, table_name;
	
2023-07-11 19:01:01.730 UTC [58] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:01.739 UTC [58] LOG:  execute s60: SELECT
	    schemainfo.nspname AS namespace,
	    tableinfo.relname AS table_name,
		constr.conname AS constraint_name,
		constr.contype AS constraint_type,
		pg_get_constraintdef(constr.oid) AS constraint_definition,
		constr.condeferrable AS is_deferrable,
		constr.condeferred AS is_deferred
	FROM pg_constraint constr
	JOIN pg_class AS tableinfo
		ON tableinfo.oid = constr.conrelid
	JOIN pg_namespace AS schemainfo
		ON schemainfo.oid = tableinfo.relnamespace
	WHERE schemainfo.nspname = ANY ( $1 )
		AND contype NOT IN ('p', 'u', 'f')
	ORDER BY namespace, table_name, constr.contype, constraint_name;
	
2023-07-11 19:01:01.739 UTC [58] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:01.745 UTC [58] LOG:  execute s61: SELECT
	    views.viewname AS view_name,
	    views.definition AS view_sql,
	    views.schemaname AS namespace,
	    description.description AS description
	FROM pg_catalog.pg_views views
	INNER JOIN pg_catalog.pg_namespace ns ON views.schemaname = ns.nspname
	INNER JOIN pg_catalog.pg_class class ON class.relnamespace = ns.oid AND class.relname = views.viewname
	LEFT JOIN pg_catalog.pg_description description ON description.objoid = class.oid AND description.objsubid = 0
	WHERE schemaname = ANY ( $1 )
	
2023-07-11 19:01:01.745 UTC [58] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:01.751 UTC [58] LOG:  execute s62: 
	            SELECT t.typname as name, e.enumlabel as value, n.nspname as namespace, d.description
	            FROM pg_type t
	            JOIN pg_enum e ON t.oid = e.enumtypid
	            JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	            LEFT OUTER JOIN pg_description d ON d.objoid = t.oid
	            WHERE n.nspname = ANY ( $1 )
	            ORDER BY e.enumsortorder
2023-07-11 19:01:01.751 UTC [58] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:01.772 UTC [58] LOG:  execute s63: 
	            SELECT
	                oid.namespace,
	                info.table_name,
	                info.column_name,
	                format_type(att.atttypid, att.atttypmod) as formatted_type,
	                info.numeric_precision,
	                info.numeric_scale,
	                info.numeric_precision_radix,
	                info.datetime_precision,
	                info.data_type,
	                info.udt_schema as type_schema_name,
	                info.udt_name as full_data_type,
	                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,
	                info.is_nullable,
	                info.is_identity,
	                info.character_maximum_length,
	                description.description
	            FROM information_schema.columns info
	            JOIN pg_attribute att ON att.attname = info.column_name
	            JOIN (
	                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace
	                 FROM pg_class
	                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace
	                 AND pg_namespace.nspname = ANY ( $1 )
	                ) as oid on oid.oid = att.attrelid 
	                  AND relname = info.table_name
	                  AND namespace = info.table_schema
	            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace
	            LEFT OUTER JOIN pg_description description ON description.objoid = att.attrelid AND description.objsubid = ordinal_position
	            WHERE table_schema = ANY ( $1 ) 
	            ORDER BY namespace, table_name, ordinal_position;
	        
2023-07-11 19:01:01.772 UTC [58] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:01.785 UTC [58] LOG:  execute s64: 
	            SELECT
	                con.oid         AS "con_id",
	                att2.attname    AS "child_column",
	                cl.relname      AS "parent_table",
	                att.attname     AS "parent_column",
	                con.confdeltype,
	                con.confupdtype,
	                rel_ns.nspname  AS "referenced_schema_name",
	                conname         AS constraint_name,
	                child,
	                parent,
	                table_name, 
	                namespace,
	                condeferrable,
	                condeferred
	            FROM (SELECT 
	                        ns.nspname AS "namespace",
	                        unnest(con1.conkey)                AS "parent",
	                        unnest(con1.confkey)                AS "child",
	                        cl.relname                          AS table_name,
	                        ns.nspname                          AS schema_name,
	                        generate_subscripts(con1.conkey, 1) AS colidx,
	                        con1.oid,
	                        con1.confrelid,
	                        con1.conrelid,
	                        con1.conname,
	                        con1.confdeltype,
	                        con1.confupdtype,
	                        con1.condeferrable                  AS condeferrable,
	                        con1.condeferred                    AS condeferred
	                FROM pg_class cl
	                        join pg_constraint con1 on con1.conrelid = cl.oid
	                        join pg_namespace ns on cl.relnamespace = ns.oid
	                WHERE
	                    ns.nspname = ANY ( $1 )
	                    and con1.contype = 'f'
	                ORDER BY colidx
	                ) con
	                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
	                    JOIN pg_class cl on cl.oid = con.confrelid
	                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
	                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid
	                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid
	            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx;
	        
2023-07-11 19:01:01.785 UTC [58] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:01.800 UTC [58] LOG:  execute s65: WITH rawindex AS (
	    SELECT
	        indrelid, 
	        indexrelid,
	        indisunique,
	        indisprimary,
	        unnest(indkey) AS indkeyid,
	        generate_subscripts(indkey, 1) AS indkeyidx,
	        unnest(indclass) AS indclass,
	        unnest(indoption) AS indoption
	    FROM pg_index -- https://www.postgresql.org/docs/current/catalog-pg-index.html
	    WHERE
	        indpred IS NULL -- filter out partial indexes
	        AND NOT indisexclusion -- filter out exclusion constraints
	)
	SELECT
	    schemainfo.nspname AS namespace,
	    indexinfo.relname AS index_name,
	    tableinfo.relname AS table_name,
	    columninfo.attname AS column_name,
	    rawindex.indisunique AS is_unique,
	    rawindex.indisprimary AS is_primary_key,
	    rawindex.indkeyidx AS column_index,
	    opclass.opcname AS opclass,
	    opclass.opcdefault AS opcdefault,
	    indexaccess.amname AS index_algo,
	    CASE rawindex.indoption & 1
	        WHEN 1 THEN 'DESC'
	        ELSE 'ASC' END
	        AS column_order,
	    CASE rawindex.indoption & 2
	        WHEN 2 THEN true
	        ELSE false END
	        AS nulls_first,
	    pc.condeferrable AS condeferrable,
	    pc.condeferred AS condeferred
	FROM
	    rawindex
	    INNER JOIN pg_class AS tableinfo ON tableinfo.oid = rawindex.indrelid
	    INNER JOIN pg_class AS indexinfo ON indexinfo.oid = rawindex.indexrelid
	    INNER JOIN pg_namespace AS schemainfo ON schemainfo.oid = tableinfo.relnamespace
	    LEFT JOIN pg_attribute AS columninfo
	        ON columninfo.attrelid = tableinfo.oid AND columninfo.attnum = rawindex.indkeyid
	    INNER JOIN pg_am AS indexaccess ON indexaccess.oid = indexinfo.relam
	    LEFT JOIN pg_opclass AS opclass -- left join because crdb has no opclasses
	        ON opclass.oid = rawindex.indclass
	    LEFT JOIN pg_constraint pc ON rawindex.indexrelid = pc.conindid AND pc.contype <> 'f'
	WHERE schemainfo.nspname = ANY ( $1 )
	ORDER BY namespace, table_name, index_name, column_index;
	
2023-07-11 19:01:01.800 UTC [58] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:01.812 UTC [58] LOG:  execute s66: 
	            SELECT p.proname AS name, n.nspname as namespace,
	                CASE WHEN l.lanname = 'internal' THEN p.prosrc
	                     ELSE pg_get_functiondef(p.oid)
	                     END as definition
	            FROM pg_proc p
	            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
	            LEFT JOIN pg_language l ON p.prolang = l.oid
	            WHERE n.nspname = ANY ( $1 )
	        
2023-07-11 19:01:01.812 UTC [58] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:01.818 UTC [58] LOG:  execute s67: SELECT
	    ext.extname AS extension_name,
	    ext.extversion AS extension_version,
	    ext.extrelocatable AS extension_relocatable,
	    pn.nspname AS extension_schema
	FROM pg_extension ext
	INNER JOIN pg_namespace pn ON ext.extnamespace = pn.oid
	ORDER BY ext.extname ASC
	
2023-07-11 19:01:01.822 UTC [58] LOG:  execute s68: 
	              SELECT
	                  sequence_name,
	                  sequence_schema AS namespace,
	                  start_value::INT8,
	                  minimum_value::INT8 AS min_value,
	                  maximum_value::INT8 AS max_value,
	                  increment::INT8 AS increment_by,
	                  (CASE cycle_option WHEN 'yes' THEN TRUE ELSE FALSE END) AS cycle,
	                  0::INT8 AS cache_size
	              FROM information_schema.sequences
	              WHERE sequence_schema = ANY ( $1 )
	              ORDER BY sequence_name
	            
2023-07-11 19:01:01.822 UTC [58] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:01.824 UTC [54] LOG:  statement: DROP DATABASE IF EXISTS "prisma_migrate_shadow_db_59511d51-73cc-47aa-8372-43b382fbd672"
2023-07-11 19:01:01.828 UTC [28] LOG:  checkpoint starting: immediate force wait
2023-07-11 19:01:01.939 UTC [28] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.024 s, sync=0.025 s, total=0.112 s; sync files=4, longest=0.022 s, average=0.007 s; distance=4529 kB, estimate=4529 kB
2023-07-11 19:01:04.105 UTC [54] LOG:  statement: SELECT pg_advisory_lock(72707369)
2023-07-11 19:01:04.119 UTC [54] LOG:  execute s69: 
	                SELECT tbl.relname AS table_name
	                FROM pg_class AS tbl
	                INNER JOIN pg_namespace AS namespace ON namespace.oid = tbl.relnamespace
	                WHERE tbl.relkind = 'r' AND namespace.nspname = ANY ( $1 )
	            
2023-07-11 19:01:04.119 UTC [54] DETAIL:  parameters: $1 = '{public}'
2023-07-11 19:01:04.125 UTC [54] LOG:  execute s70: SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
2023-07-11 19:01:04.129 UTC [54] LOG:  execute s71: INSERT INTO "_prisma_migrations" ("id","checksum","started_at","migration_name") VALUES ($1,$2,$3,$4)
2023-07-11 19:01:04.129 UTC [54] DETAIL:  parameters: $1 = '4ebfd1c8-e7b0-4e32-b219-c4e4bc242c93', $2 = '64517269237c203d497d1166019d066a0aaa47f217d132ac4ddfd23e48a9b886', $3 = '2023-07-11 19:01:04.127192+00', $4 = '20230711190104_add_carga_horaria_table_disciplina'
2023-07-11 19:01:04.135 UTC [54] LOG:  statement: /*
	  Warnings:
	
	  - Added the required column `carga_horaria` to the `Disciplina` table without a default value. This is not possible if the table is not empty.
	
	*/
	-- AlterTable
	ALTER TABLE "Disciplina" ADD COLUMN     "carga_horaria" INTEGER NOT NULL;
	
2023-07-11 19:01:04.152 UTC [54] LOG:  execute s72: UPDATE "_prisma_migrations" SET "applied_steps_count" = ("applied_steps_count" + $1) WHERE "id" = $2
2023-07-11 19:01:04.152 UTC [54] DETAIL:  parameters: $1 = '1', $2 = '4ebfd1c8-e7b0-4e32-b219-c4e4bc242c93'
2023-07-11 19:01:04.160 UTC [54] LOG:  execute s73: UPDATE "_prisma_migrations" SET "finished_at" = $1 WHERE "id" = $2
2023-07-11 19:01:04.160 UTC [54] DETAIL:  parameters: $1 = '2023-07-11 19:01:04.158221+00', $2 = '4ebfd1c8-e7b0-4e32-b219-c4e4bc242c93'
2023-07-11 19:01:11.540 UTC [59] LOG:  statement: select version()
2023-07-11 19:01:11.545 UTC [59] LOG:  statement: 
	    SELECT
	      r.specific_name as id,
	      r.routine_schema as routine_schema,
	      r.routine_name as name,
	      r.routine_type as routine_type,
	      r.data_type as data_type
	    FROM INFORMATION_SCHEMA.ROUTINES r
	    where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	    ORDER BY routine_schema, routine_name
	  
2023-07-11 19:01:11.589 UTC [60] LOG:  statement: select version()
2023-07-11 19:01:11.593 UTC [60] LOG:  statement: 
	    SELECT
	      t.table_schema as schema,
	      t.table_name as name,
	  
	        pc.relkind as tabletype
	      FROM information_schema.tables AS t
	      JOIN pg_class AS pc
	        ON t.table_name = pc.relname AND quote_ident(t.table_schema) = pc.relnamespace::regnamespace::text
	      LEFT OUTER JOIN pg_inherits AS i
	        ON pc.oid = i.inhrelid
	      WHERE t.table_type NOT LIKE '%VIEW%'
	      AND i.inhrelid::regclass IS NULL
	    
	    
	    ORDER BY t.table_schema, t.table_name
	  
2023-07-11 19:01:11.610 UTC [59] LOG:  statement: 
	    select
	        r.routine_schema as routine_schema,
	        r.specific_name as specific_name,
	        p.parameter_name as parameter_name,
	        p.character_maximum_length as char_length,
	        p.data_type as data_type
	  from information_schema.routines r
	  left join information_schema.parameters p
	            on p.specific_schema = r.routine_schema
	            and p.specific_name = r.specific_name
	  where r.routine_schema not in ('sys', 'information_schema',
	                                'pg_catalog', 'performance_schema')
	    
	
	      AND p.parameter_mode = 'IN'
	  order by r.routine_schema,
	          r.specific_name,
	          p.ordinal_position;
	
	  
2023-07-11 19:01:11.635 UTC [60] LOG:  statement: 
	    SELECT
	      table_schema as schema,
	      table_name as name
	    FROM information_schema.views
	    
	    ORDER BY table_schema, table_name
	  
2023-07-11 19:01:11.641 UTC [60] LOG:  statement: select version()
2023-07-11 19:01:11.644 UTC [60] LOG:  statement: 
	    SELECT
	      schemaname as schema,
	      matviewname as name
	    FROM pg_matviews
	    
	    order by schemaname, matviewname;
	  
2023-07-11 19:01:11.745 UTC [60] LOG:  statement: select version()
2023-07-11 19:01:11.775 UTC [60] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-11 19:01:11.842 UTC [60] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-11 19:01:11.842 UTC [60] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-11 19:01:11.884 UTC [60] LOG:  statement: select version()
2023-07-11 19:01:11.885 UTC [59] LOG:  statement: select version()
2023-07-11 19:01:11.946 UTC [60] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-11 19:01:11.948 UTC [59] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-11 19:01:11.954 UTC [60] LOG:  statement: select version()
2023-07-11 19:01:11.967 UTC [60] LOG:  statement: 
	    SELECT * 
	    FROM "public"."Disciplina"
	    
	  
	    order by "id" asc
	    LIMIT 100
	    OFFSET 0
	    
2023-07-11 19:01:12.114 UTC [61] LOG:  execute <unnamed>: 
	    SELECT
	      table_schema,
	      table_name,
	      column_name,
	      is_nullable,
	      ordinal_position,
	      column_default,
	      CASE
	        WHEN character_maximum_length is not null  and udt_name != 'text'
	          THEN CONCAT(udt_name, concat('(', concat(character_maximum_length::varchar(255), ')')))
	        WHEN datetime_precision is not null THEN
	          CONCAT(udt_name, concat('(', concat(datetime_precision::varchar(255), ')')))
	        ELSE udt_name
	      END as data_type
	    FROM information_schema.columns
	    WHERE table_schema = $1 AND table_name = $2
	    ORDER BY table_schema, table_name, ordinal_position
	  
2023-07-11 19:01:12.114 UTC [61] DETAIL:  parameters: $1 = 'public', $2 = 'Disciplina'
2023-07-11 19:06:02.028 UTC [28] LOG:  checkpoint starting: time
2023-07-11 19:06:02.969 UTC [28] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.852 s, sync=0.025 s, total=0.941 s; sync files=8, longest=0.008 s, average=0.004 s; distance=34 kB, estimate=4079 kB
2023-07-11 19:24:11.931 UTC [62] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-11 19:24:11.931 UTC [62] DETAIL:  parameters: $1 = '16537'
2023-07-11 19:24:11.941 UTC [62] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-11 19:24:11.941 UTC [62] DETAIL:  parameters: $1 = '16537'
2023-07-11 19:24:11.951 UTC [62] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:11.951 UTC [62] DETAIL:  parameters: $1 = 'maria@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:24:11.959 UTC [62] LOG:  execute s1: SELECT t.typname, t.typtype, t.typelem, r.rngsubtype, t.typbasetype, n.nspname, t.typrelid
	FROM pg_catalog.pg_type t
	LEFT OUTER JOIN pg_catalog.pg_range r ON r.rngtypid = t.oid
	INNER JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
	WHERE t.oid = $1
	
2023-07-11 19:24:11.959 UTC [62] DETAIL:  parameters: $1 = '16419'
2023-07-11 19:24:11.961 UTC [62] LOG:  execute s2: SELECT enumlabel
	FROM pg_catalog.pg_enum
	WHERE enumtypid = $1
	ORDER BY enumsortorder
	
2023-07-11 19:24:11.961 UTC [62] DETAIL:  parameters: $1 = '16419'
2023-07-11 19:24:11.969 UTC [62] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:11.969 UTC [62] DETAIL:  parameters: $1 = '12345678901', $2 = '1', $3 = '0'
2023-07-11 19:24:11.974 UTC [62] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:11.974 UTC [62] DETAIL:  parameters: $1 = 'maria@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:24:12.096 UTC [62] LOG:  statement: BEGIN
2023-07-11 19:24:12.106 UTC [62] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:24:12.106 UTC [62] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-11 19:24:12.113 UTC [62] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:24:12.113 UTC [62] DETAIL:  parameters: $1 = '7', $2 = '0'
2023-07-11 19:24:12.123 UTC [62] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-11 19:24:12.123 UTC [62] DETAIL:  parameters: $1 = '8f004fb7-6142-4d8a-8701-2c98a538bea4', $2 = 'Maria Silva', $3 = 'maria@gmail.com', $4 = '12345678901', $5 = 'F', $6 = '9876543210', $7 = '2023-07-11 19:24:12.082', $8 = '7', $9 = '6'
2023-07-11 19:24:12.127 UTC [62] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-11 19:24:12.127 UTC [62] DETAIL:  parameters: $1 = '45a43f61-924e-4c4f-aacd-4fc89726f8d7', $2 = 'maria@gmail.com', $3 = '$2b$10$c8t1BrnL7j5C2uG.PJ4Ohe1BWgPLUxcplXyRqg76thDFrZ7/FIwn6', $4 = 'aluno', $5 = '8f004fb7-6142-4d8a-8701-2c98a538bea4'
2023-07-11 19:24:12.133 UTC [62] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:12.133 UTC [62] DETAIL:  parameters: $1 = '8f004fb7-6142-4d8a-8701-2c98a538bea4', $2 = '1', $3 = '0'
2023-07-11 19:24:12.135 UTC [62] LOG:  statement: COMMIT
2023-07-11 19:24:34.207 UTC [62] LOG:  statement: SELECT 1
2023-07-11 19:24:34.209 UTC [62] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:34.209 UTC [62] DETAIL:  parameters: $1 = 'joao@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:24:34.212 UTC [62] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:34.212 UTC [62] DETAIL:  parameters: $1 = '98765432109', $2 = '1', $3 = '0'
2023-07-11 19:24:34.216 UTC [62] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:34.216 UTC [62] DETAIL:  parameters: $1 = 'joao@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:24:34.320 UTC [62] LOG:  statement: BEGIN
2023-07-11 19:24:34.322 UTC [62] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:24:34.322 UTC [62] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-11 19:24:34.324 UTC [62] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:24:34.324 UTC [62] DETAIL:  parameters: $1 = '7', $2 = '0'
2023-07-11 19:24:34.327 UTC [62] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-11 19:24:34.327 UTC [62] DETAIL:  parameters: $1 = 'a6dda887-5e42-4a76-af93-a604d6cf1f74', $2 = 'Joo Santos', $3 = 'joao@gmail.com', $4 = '98765432109', $5 = 'M', $6 = '1234567890', $7 = '2023-07-11 19:24:34.32', $8 = '7', $9 = '6'
2023-07-11 19:24:34.330 UTC [62] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-11 19:24:34.330 UTC [62] DETAIL:  parameters: $1 = '964a8062-88ed-40fa-a592-2f09cda9b0b9', $2 = 'joao@gmail.com', $3 = '$2b$10$mFjinRRYsbFqqDhLJpzBhu8cpDIm35pgapJyoi73fXZbc22UKdEgm', $4 = 'aluno', $5 = 'a6dda887-5e42-4a76-af93-a604d6cf1f74'
2023-07-11 19:24:34.332 UTC [62] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:34.332 UTC [62] DETAIL:  parameters: $1 = 'a6dda887-5e42-4a76-af93-a604d6cf1f74', $2 = '1', $3 = '0'
2023-07-11 19:24:34.333 UTC [62] LOG:  statement: COMMIT
2023-07-11 19:24:41.468 UTC [62] LOG:  execute s10: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE 1=1 OFFSET $1
2023-07-11 19:24:41.468 UTC [62] DETAIL:  parameters: $1 = '0'
2023-07-11 19:24:58.370 UTC [62] LOG:  statement: SELECT 1
2023-07-11 19:24:58.372 UTC [62] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:58.372 UTC [62] DETAIL:  parameters: $1 = 'ana@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:24:58.376 UTC [62] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:58.376 UTC [62] DETAIL:  parameters: $1 = '12345678902', $2 = '1', $3 = '0'
2023-07-11 19:24:58.379 UTC [62] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:58.379 UTC [62] DETAIL:  parameters: $1 = 'ana@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:24:58.477 UTC [62] LOG:  statement: BEGIN
2023-07-11 19:24:58.479 UTC [62] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:24:58.479 UTC [62] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-11 19:24:58.481 UTC [62] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:24:58.481 UTC [62] DETAIL:  parameters: $1 = '7', $2 = '0'
2023-07-11 19:24:58.483 UTC [62] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-11 19:24:58.483 UTC [62] DETAIL:  parameters: $1 = '41c073ce-6e28-4aec-9ce0-d74975bdf47d', $2 = 'Ana Santos', $3 = 'ana@gmail.com', $4 = '12345678902', $5 = 'F', $6 = '9876543211', $7 = '2023-07-11 19:24:58.476', $8 = '7', $9 = '6'
2023-07-11 19:24:58.486 UTC [62] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-11 19:24:58.486 UTC [62] DETAIL:  parameters: $1 = 'fec5ccc7-f68a-4493-8a8b-0c534ccf463e', $2 = 'ana@gmail.com', $3 = '$2b$10$z3iYRF4vymN7IKg2g5n/Cu/Cc7iXODSssTlcGQ8jDNiXX69x.myyy', $4 = 'aluno', $5 = '41c073ce-6e28-4aec-9ce0-d74975bdf47d'
2023-07-11 19:24:58.488 UTC [62] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:24:58.488 UTC [62] DETAIL:  parameters: $1 = '41c073ce-6e28-4aec-9ce0-d74975bdf47d', $2 = '1', $3 = '0'
2023-07-11 19:24:58.490 UTC [62] LOG:  statement: COMMIT
2023-07-11 19:25:18.010 UTC [62] LOG:  statement: SELECT 1
2023-07-11 19:25:18.012 UTC [62] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:18.012 UTC [62] DETAIL:  parameters: $1 = 'pedro@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:25:18.016 UTC [62] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:18.016 UTC [62] DETAIL:  parameters: $1 = '98765432103', $2 = '1', $3 = '0'
2023-07-11 19:25:18.021 UTC [62] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:18.021 UTC [62] DETAIL:  parameters: $1 = 'pedro@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:25:18.121 UTC [62] LOG:  statement: BEGIN
2023-07-11 19:25:18.123 UTC [62] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:25:18.123 UTC [62] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-11 19:25:18.125 UTC [62] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:25:18.125 UTC [62] DETAIL:  parameters: $1 = '7', $2 = '0'
2023-07-11 19:25:18.127 UTC [62] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-11 19:25:18.127 UTC [62] DETAIL:  parameters: $1 = 'bde1fdeb-7b30-484b-a697-8531505e30c7', $2 = 'Pedro Oliveira', $3 = 'pedro@gmail.com', $4 = '98765432103', $5 = 'M', $6 = '1234567892', $7 = '2023-07-11 19:25:18.121', $8 = '7', $9 = '6'
2023-07-11 19:25:18.129 UTC [62] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-11 19:25:18.129 UTC [62] DETAIL:  parameters: $1 = 'cf740ec7-cb0c-4f12-a3ef-32d0a667eaa3', $2 = 'pedro@gmail.com', $3 = '$2b$10$xQY3dlClzvOB.cvfXMpK1.K7y4aP5vCf9wyXRQhQC3W393fHb6Esu', $4 = 'aluno', $5 = 'bde1fdeb-7b30-484b-a697-8531505e30c7'
2023-07-11 19:25:18.131 UTC [62] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:18.131 UTC [62] DETAIL:  parameters: $1 = 'bde1fdeb-7b30-484b-a697-8531505e30c7', $2 = '1', $3 = '0'
2023-07-11 19:25:18.134 UTC [62] LOG:  statement: COMMIT
2023-07-11 19:25:32.188 UTC [62] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:32.188 UTC [62] DETAIL:  parameters: $1 = 'mariana@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:25:32.191 UTC [62] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:32.191 UTC [62] DETAIL:  parameters: $1 = '12345678904', $2 = '1', $3 = '0'
2023-07-11 19:25:32.195 UTC [62] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:32.195 UTC [62] DETAIL:  parameters: $1 = 'mariana@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:25:32.297 UTC [62] LOG:  statement: BEGIN
2023-07-11 19:25:32.298 UTC [62] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:25:32.298 UTC [62] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-11 19:25:32.300 UTC [62] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:25:32.300 UTC [62] DETAIL:  parameters: $1 = '7', $2 = '0'
2023-07-11 19:25:32.302 UTC [62] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-11 19:25:32.302 UTC [62] DETAIL:  parameters: $1 = '358311e9-3006-4e64-a6a1-b17ece58f225', $2 = 'Mariana Costa', $3 = 'mariana@gmail.com', $4 = '12345678904', $5 = 'F', $6 = '9876543213', $7 = '2023-07-11 19:25:32.299', $8 = '7', $9 = '6'
2023-07-11 19:25:32.305 UTC [62] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-11 19:25:32.305 UTC [62] DETAIL:  parameters: $1 = '5e15b9ba-4f3f-4ba1-9482-eb5c4afa7de2', $2 = 'mariana@gmail.com', $3 = '$2b$10$2SsOlCwAwwNOG/0ICqNxR.gNomM57rMGuPP1UnJ1KvP7cUlmNeFEm', $4 = 'aluno', $5 = '358311e9-3006-4e64-a6a1-b17ece58f225'
2023-07-11 19:25:32.308 UTC [62] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:32.308 UTC [62] DETAIL:  parameters: $1 = '358311e9-3006-4e64-a6a1-b17ece58f225', $2 = '1', $3 = '0'
2023-07-11 19:25:32.310 UTC [62] LOG:  statement: COMMIT
2023-07-11 19:25:40.881 UTC [62] LOG:  statement: SELECT 1
2023-07-11 19:25:40.883 UTC [62] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:40.883 UTC [62] DETAIL:  parameters: $1 = 'rafael@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:25:40.886 UTC [62] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:40.886 UTC [62] DETAIL:  parameters: $1 = '98765432105', $2 = '1', $3 = '0'
2023-07-11 19:25:40.889 UTC [62] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:40.889 UTC [62] DETAIL:  parameters: $1 = 'rafael@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:25:40.997 UTC [62] LOG:  statement: BEGIN
2023-07-11 19:25:40.999 UTC [62] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:25:40.999 UTC [62] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-11 19:25:41.000 UTC [62] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:25:41.000 UTC [62] DETAIL:  parameters: $1 = '7', $2 = '0'
2023-07-11 19:25:41.002 UTC [62] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-11 19:25:41.002 UTC [62] DETAIL:  parameters: $1 = '74851586-455b-4903-8b15-954037feae63', $2 = 'Rafael Silva', $3 = 'rafael@gmail.com', $4 = '98765432105', $5 = 'M', $6 = '1234567894', $7 = '2023-07-11 19:25:40.999', $8 = '7', $9 = '6'
2023-07-11 19:25:41.004 UTC [62] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-11 19:25:41.004 UTC [62] DETAIL:  parameters: $1 = '9111ea45-0278-4629-976d-0c9b2c3e7288', $2 = 'rafael@gmail.com', $3 = '$2b$10$9MbjWb1t8WEAZryvgRhVvefPxOuFar5LgDHaCE70S6LLlp1uGJiQG', $4 = 'aluno', $5 = '74851586-455b-4903-8b15-954037feae63'
2023-07-11 19:25:41.006 UTC [62] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:41.006 UTC [62] DETAIL:  parameters: $1 = '74851586-455b-4903-8b15-954037feae63', $2 = '1', $3 = '0'
2023-07-11 19:25:41.007 UTC [62] LOG:  statement: COMMIT
2023-07-11 19:25:48.835 UTC [62] LOG:  execute s0: SELECT "public"."User"."id", "public"."User"."email", "public"."User"."password", "public"."User"."status", "public"."User"."id_departamento", "public"."User"."id_professor", "public"."User"."id_aluno" FROM "public"."User" WHERE "public"."User"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:48.835 UTC [62] DETAIL:  parameters: $1 = 'camila@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:25:48.838 UTC [62] LOG:  execute s3: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."cpf" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:48.838 UTC [62] DETAIL:  parameters: $1 = '12345678906', $2 = '1', $3 = '0'
2023-07-11 19:25:48.842 UTC [62] LOG:  execute s4: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."email" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:48.842 UTC [62] DETAIL:  parameters: $1 = 'camila@gmail.com', $2 = '1', $3 = '0'
2023-07-11 19:25:48.953 UTC [62] LOG:  statement: BEGIN
2023-07-11 19:25:48.955 UTC [62] LOG:  execute s5: SELECT "public"."Curso"."id" FROM "public"."Curso" WHERE ("public"."Curso"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:25:48.955 UTC [62] DETAIL:  parameters: $1 = '6', $2 = '0'
2023-07-11 19:25:48.956 UTC [62] LOG:  execute s6: SELECT "public"."Turma"."id" FROM "public"."Turma" WHERE ("public"."Turma"."id" = $1 AND 1=1) OFFSET $2
2023-07-11 19:25:48.956 UTC [62] DETAIL:  parameters: $1 = '7', $2 = '0'
2023-07-11 19:25:48.958 UTC [62] LOG:  execute s7: INSERT INTO "public"."Aluno" ("id","nome","email","cpf","sexo","telefone","createdAt","id_turma","id_curso") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING "public"."Aluno"."id"
2023-07-11 19:25:48.958 UTC [62] DETAIL:  parameters: $1 = 'e386c18c-cc1f-404b-ae67-436da976c050', $2 = 'Camila Rodrigues', $3 = 'camila@gmail.com', $4 = '12345678906', $5 = 'F', $6 = '9876543215', $7 = '2023-07-11 19:25:48.953', $8 = '7', $9 = '6'
2023-07-11 19:25:48.960 UTC [62] LOG:  execute s8: INSERT INTO "public"."User" ("id","email","password","status","id_aluno") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
2023-07-11 19:25:48.960 UTC [62] DETAIL:  parameters: $1 = '663dfd40-bece-47be-8d9a-bc302d2a03e9', $2 = 'camila@gmail.com', $3 = '$2b$10$1kPQvhmNbG5wYImhpLlVf.sbSUksEpAR3WwLNdPrSVRuwnwwYAFy6', $4 = 'aluno', $5 = 'e386c18c-cc1f-404b-ae67-436da976c050'
2023-07-11 19:25:48.963 UTC [62] LOG:  execute s9: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE "public"."Aluno"."id" = $1 LIMIT $2 OFFSET $3
2023-07-11 19:25:48.963 UTC [62] DETAIL:  parameters: $1 = 'e386c18c-cc1f-404b-ae67-436da976c050', $2 = '1', $3 = '0'
2023-07-11 19:25:48.965 UTC [62] LOG:  statement: COMMIT
2023-07-11 19:26:03.298 UTC [28] LOG:  checkpoint starting: time
2023-07-11 19:26:04.268 UTC [28] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.859 s, sync=0.014 s, total=0.971 s; sync files=8, longest=0.004 s, average=0.002 s; distance=16 kB, estimate=3673 kB
2023-07-11 19:26:08.165 UTC [62] LOG:  statement: SELECT 1
2023-07-11 19:26:08.167 UTC [62] LOG:  execute s10: SELECT "public"."Aluno"."id", "public"."Aluno"."nome", "public"."Aluno"."email", "public"."Aluno"."cpf", "public"."Aluno"."sexo", "public"."Aluno"."telefone", "public"."Aluno"."createdAt", "public"."Aluno"."id_turma", "public"."Aluno"."id_curso" FROM "public"."Aluno" WHERE 1=1 OFFSET $1
2023-07-11 19:26:08.167 UTC [62] DETAIL:  parameters: $1 = '0'
